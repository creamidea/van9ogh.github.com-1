<p>&lt;?xml version="1.0" encoding="utf-8"?>
  &lt;rss version="2.0"</p>

<pre><code>    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:atom="http://www.w3.org/2005/Atom"
</code></pre>

<blockquote><p>  <channel></p>

<pre><code>&lt;title&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/title&gt;
&lt;link href="/feed/" rel="self" /&gt;
&lt;link href="http://van9ogh.github.com/" /&gt;
&lt;lastBuildDate&gt;2013-01-28T16:34:33+08:00&lt;/lastBuildDate&gt;
&lt;webMaster&gt;cow(dot)vangogh(alt)gmail(dot)com&lt;/webMaster&gt;
</code></pre></blockquote>

<pre><code>&lt;item&gt;
  &lt;title&gt;使用新的域名: forestgump.me&lt;/title&gt;
  &lt;link href="/2013/01/new-domain/"/&gt;
  &lt;pubDate&gt;2013-01-25T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2013/01/new-domain&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;p&gt;域名其实半年前就想去注册的, 一直没有时间, 一开始还以为只要域名无法访问, 域名就没有被人注册(因为一开始我想注册的是quick.com, 其实查询需要到whois上, &lt;strong&gt;quick.com&lt;/strong&gt;早在&lt;strong&gt;199x&lt;/strong&gt;年就被抢注了).于是苦思冥想之后, 发现forestgump.me(阿甘)还没有被注册, 说来也奇怪, forestgump.com在2012年才有人想要注册, 如果当时动作快点, 或许这个域名还有机会, 话说.me域名原来是门的内哥罗(Montenegro，旧译“黑山”)的国家域名. 本文主要是记录注册的这个过程, 方便以后查阅.&lt;/p&gt;
</code></pre>

<p>域名提供商选的是godaddy, 在淘宝上花了55元, 过户很快, 几分钟搞定, 接下来就是尝试将github pages迁移一下, 将A记录修改为204.232.175.78, 又添加了一条CNAME: van9ogh.github.com, 然后去github对应的repo中添加了一个文件, 内容为: forestgump.me, 就都完成了.</p>




<p>这中间, 顺带尝试了自定义域名邮件服务, 原本以为Gmail会提供, 居然没找到china!, 地址在这里:<a href="https://www.google.com/a/signup/?hl=en&amp;source=gafb-persemail-en">Google App for Business</a>. 而Hotmail, 微软弄了很多窗口加上Windows8有大又累赘的标签风格, 实在没有明白. 最后尝试了一下163, 定制了一个<a href="http://mail.forestgump.me">mail</a>页面, 不过MX记录验证还没有通过, 应该问题不大. 再次吐嘈一下Hotmail, 又是live.com, 又是hotmail.com, 又是microsoft.com, 有点像踢皮球. 这摆明了是在玩弄程序员!</p>




<p>有空再尝试下<a href="http://www.dnspod.com">DnsPod</a>、<a href="http://www.opendns.com">OpenDNS</a>, 不过貌似在家也很快, 也没有被墙.(铁通 2M 网络)</p>




<p>最近也有被PaaS 平台所吸引, 虽然没有VPS灵活性高, 但框架和App确实也可以做很多事情, 比如说GAE+goagnet, 以及Paas+svona等应gfw而生的tools. 而VPS甚至可以做到借助<a href="http://dnstunnel.de/">dns tunnel</a>, <a href="http://www.cs.uit.no/~daniels/PingTunnel/">ping tunnel</a>隧道免费上网, 这个换做PaaS可做不到, 除非平台提供, 因为我们无法私自开启端口. 原理其实很类似, 无非是使用server+client借助其它的协议(www、icmp、dns)将data从一个点搬运到另一个点. 如果为躲避gfw, 当然还需要tunnel技术.</p>




<p>Github Pages和Paas以及VPS比起来, 其实已经很好的满足了需求, 因为对于blog, 并不需要数据库, 甚至不需要自己的搜索引擎(google的站点搜索足够了): 简单性是系统设计的第一要素，实现的简单比接口的简单更重要；任何值得注意的方面都要求正确性，但为了简单性，正确性可以轻微让步；设计不能过于不一致，但为了简单性，一致性可以有所牺牲；完备性应该覆盖实践中许多重要的情况，但只要简单性受到危害，完备性必须作出牺牲。这也是Richard Gabriel的<a href="http://www.jwz.org/doc/worse-is-better.html">worse is better</a>要说的.</p>




<h3>Links</h3>




<ul>
<li><a href="http://www.whois.com/">whois</a> 查询域名信息, 也可以到域名注册商那查询</li>
<li><a href="http://www.godaddy.com/">godaddy</a> 最大的域名注册商</li>
<li><a href="http://www.dnspod.com">dnspod</a> DNS智能加速(国内)</li>
<li><a href="http://www.opendns.com">OpenDNS</a> 提供DNS优化服务</li>
<li><a href="http://www.name.com">name.com</a> name.com的网站用户体验比godaddy好很多, 也很推荐!</li>
<li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">Github pages</a>  阮一峰的这篇讲Github Pages介绍的挺好.</li>
</ul>




<p> [全文完]</p>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;Lua学习笔记(2): 协程&lt;/title&gt;
  &lt;link href="/2013/01/lua-coroutine/"/&gt;
  &lt;pubDate&gt;2013-01-09T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2013/01/lua-coroutine&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;p&gt;这篇文章来自于阅读lua的作者写的&lt;a href="http://www.inf.puc-rio.br/~roberto/docs/corosblp.pdf"&gt;coroutines in lua&lt;/a&gt;, 翻译了一部分, 又加入一些了自己的理解. 形式化描述那部分没有翻译, 还有一些关于continuation机制的也没有过多翻译, 这两个方面的链接已经列在文末.&lt;/p&gt;
</code></pre>

<h2>摘要</h2>




<p>协程在过去是一个被人遗忘的概念, 不过慢慢的又开始复兴, 大多数目前的协程实现的并不完整, 或多或少只能用在特定的场合.提供一个真正的协程往往被人所忽略, 本文一方面讨论的是Lua中的协程机制, 它是一个非对称协程的完全实现, 另一方面也向你展示这一强大的控制行为的工具.</p>




<h2>1. 简介</h2>




<p>协程是为了解决general control abstraction而提出的最古老建议之一, 贡献者是Conway(1963), 它被描述为行为像主程序的子程序, 当时的实现依靠的是COBOL编译器的词法分析和语义分析, 1980年的时候, Marlin的博士论文完整的描述了它的原理, 阐明了它的特征:</p>




<blockquote><ul>
<li>the values of data local to a coroutine persist between successive calls(数据的持久性)</li>
<li>the execution of a coroutine is suspended as control leaves it, only to carry on where it left off when control re-enters the coroutine at some later stage.(并不是并发, 类似于时分多路)</li>
</ul>
</blockquote>




<p>协程适用的场合来自于这些年的一些需求:并发编程、仿真、文本处理、人工智能以及各种数据结构的操作. 然而这一强大的control abstraction工具在通用语言设计的时候却被忽略了, 只有极少数的一些特例: Simula、BCPL、Modula2、Icon等语言.</p>




<p>这中间, 一部分的原因就是对协程的概念没有一个统一的认识, 而且很多论文中对协程的描述都来自于Simula语言, 包括Marlin的. 然而Simula本身对协程复杂的实现导致了大家都认为它是一个尴尬的、难以维护和理解的实现.</p>




<p>然而协程并没有真正被遗忘, 这些年它在慢慢复兴, 尤其是在以下两个不同的方面.一方面和开发多任务应用程序有关, 我们发现协作式的多任务比多进程环境更具有优势! 在这一应用场景中, 协程主要以library的形式出现, 比如微软的fibers(纤程), 有趣的是协程的术语都没有被提出来, 这就是需求, 因此随后概念会被技术人员抽象出来, 于是协程原地满血了.</p>




<p>另一方面就是脚本语言, 特别是Lua, Python, Perl. Python最近推出了一个受限制的协程, 能够允许simple iterators或者generators, 但是还不是足够强大: 没有实现一些有趣的功能, 包括用户层面的多任务. Perl也提出了类似的机制. 不同的是Lua, 它是一个真正意义上的协程实现.</p>




<p>本文的主要就是展示并讨论Lua中的协程机制, 安排是这样的: Section2主要是介绍一下Lua语言以及描述一下协程的机制, 提出它的操作语义(operational semantics). Section3将通过一些相关的demo来阐述这一强大的非对称协程的使用. 然后Section4将再次讨论其他语言中协程的情况. 最后Section5我们将做出总结.</p>




<h2>2. Lua Coroutines(Lua中的协程)</h2>




<p>Lua是一门轻量级的基于数据描述的通用编程语言, 特性有: dymanically typed, lexically scoped, interpreted from bytecodes, 以及垃圾回收. Lua主要被设计用来作为一门扩展语言, 嵌入到host program中(宿主主机).</p>




<p>Lua一开始就是为了更容易整合到C/C++以及其它一些conventional language中而设计的, Lua的本身是用ANSIC写成的(纯C), 因此可以支持相当多的平台, 除了Lua的解释器, Lua本身也提供了一组C function API集合, 允许host program可以和Lua通信, 通过这组API, host program就可以访问Lua脚本中的变量、调用Lua脚本中的函数了.除了这种embedded功能, 我们还可以利用这组API进行extending, 这样我们就可以在Lua脚本中调用C函数了!从这个角度, Lua可以用来构造<a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>.</p>




<p>Lua主要实现的是非对称协程, 通常被表示为semi-symmetric或者semi-coroutines, 之所以这样称呼, 是因为它有两种控制操作, 一个是为了调用(invoke)协程, 另一个是为了挂起(suspend)协程, 一旦挂起就可以返回到其他的调用协程了. 非对称协程可以认为是服从于调用者, 它们之间类似于被调用和调用例程的关系, 和这个不同的是对称的协程, 它只是简单的transfer operation来切换.由于对称协程是将控制传递给selves的, 因此selves是在同一个继承级别上的. 看似这两者都没有问题, 那为什么Lua最终选择非对称coroutine而不是对称或者他们两者呢? 我们还是有一些理由的.</p>




<p><strong>其一</strong>, 对称和非对称协程语言表达能力上是不同的, 而通用的协程机制本应该都提供, 然而事实上我们很容易演示的是对称协程可以由非对称协程来表达, 因此即使仅仅提供非对称协程, 语言的表达能力并没有被削弱, 实现它们两者只会增加语言语义的复杂度. 其实正是由于引入了对称协程导致了Simula语言在语义上的不一致.这就好比<a href="http://en.wikipedia.org/wiki/Syntactic_sugar">语法糖</a>, 其实基本的语义已经覆盖了这些功能, 添加语法糖只不过是方便了使用它的人, 但如果滥用, 就会将语言推向深渊. 读者还可以看看图灵等价, 这些思想就像当年的能量守恒定律一样, 是在维护一些科学的基本原则, 让人们明白发明能够解决一些问题的计算机语言就和永动机一样, 都不靠谱.</p>




<p><strong>其二</strong>, Simplicity and Portability</p>




<p><strong>其三</strong>, 更容易整合到宿主program</p>




<h2>2.1 Lua Coroutine Facilities</h2>




<p>Lua协程提供了三种基本的操作: create, resume, yield. 和大多数Lua的库一样, 这些函数在一张全局表内.(coroutine)</p>




<h3>coroutine.create</h3>




<div class="highlight"><pre><code class="lua"><span class="cm">--[[ 创建一个新的协程, 并为它分配一个独立的栈, 接受一个函数作为参数, 返回这个coroutine的引用.</span>
<span class="cm">     并没有excute coroutine, 这个新协程一开始被挂起, 通常参数f作为匿名函数来传入</span>
<span class="cm">    co = coroutine.create(function () ... end)</span>
<span class="cm">--]]</span>
<span class="nb">coroutine.create</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div>




<p>Lua coroutine以变量的方式被存储, 能够被当作函数参数, 或者被函数返回, 并没有严格提供删除协程的操作, 这个和Lua中其他的值一样, 通过垃圾回收机制来释放.</p>




<h3>coroutine.resume</h3>




<div class="highlight"><pre><code class="lua"><span class="cm">--[[ 激活一个协程, 第一个参数是一个协程的引用, 就是由coroutine.create返回的那个, 一旦</span>
<span class="cm">     恢复运行, 协程会在上一次断点处继续运行直到再次被挂起或者结束.</span>
<span class="cm">--]]</span>
<span class="nb">coroutine.resume</span><span class="p">(</span><span class="n">co</span> <span class="p">[,</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
</code></pre></div>




<h3>coroutine.yield</h3>




<div class="highlight"><pre><code class="lua"><span class="cm">--[[ 挂起一个协程, 此时该协程的运行状态立刻被保存, 直到调用coroutine.resume, 注意yield参数</span>
<span class="cm">     就是resume返回的参数的后面部分, 读者可以对比一下.</span>
<span class="cm">--]]</span>
<span class="nb">coroutine.yield</span><span class="p">([</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
</code></pre></div>




<p>由于协程是在一个独立的栈内实现的, coroutine.yield甚至允许发生在嵌套Lua函数(比如直接或间接地调用lua main function)一旦下一次协程resume, 它就会在完全在上一次的断点处继续执行.哪里跌倒就会在哪里爬起来.</p>




<p><strong>那么协程什么时候结束呢?</strong></p>




<ul>
<li>主函数返回的时候, 这个时候我们可以说协程Dead, 再也不会被恢复</li>
<li>运行过程中发生错误的时候, 正确返回的时候, coroutine.resume返回(true, [val1, val2, ...]), 而错误的时候将返回(falue, "error message").</li>
</ul>




<h3>coroutine.wrap</h3>




<p><strong>Lua有一个auxiliary library, 其中对coroutine又作了一些扩展, coroutine.wrap就是一个.</strong></p>




<div class="highlight"><pre><code class="lua"><span class="cm">--[[ 这个函数和coroutine.create类似, 其实是coroutine.create和coroutine.resume的包装:</span>

<span class="cm">function wrap(f)</span>
<span class="cm">   local co = coroutine.create(f)</span>
<span class="cm">   return function(v)</span>
<span class="cm">       status, ret = coroutine.resume(co, v)</span>
<span class="cm">       if status then</span>
<span class="cm">           return ret</span>
<span class="cm">       else</span>
<span class="cm">           error(ret)</span>
<span class="cm">       end</span>
<span class="cm">   end</span>
<span class="cm">--]]</span>
<span class="nb">coroutine.wrap</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div>




<p>lua提供了非常便捷的方法来让协程和它的调用者exchange data, 我们来看一些demo:</p>




<div class="highlight"><pre><code class="lua"><span class="n">co</span> <span class="o">=</span> <span class="nb">coroutine.wrap</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> 
        <span class="kd">local</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span>
     <span class="k">end</span><span class="p">)</span>

<span class="c1">-- 协程第一次被激活</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">co</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>  <span class="c1">-- 此时 b = 22</span>

<span class="c1">-- 协程第二次被激活</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">co</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">-- 此时d = 23 * 2 = 46</span>
</code></pre></div>




<h2>2.2 An Operational Semantics for Lua Asymmetric Coroutines(非对称协程的操作语义)</h2>




<p><strong>这一节为纯数学推导和定义, 可以参考<a href="http://www.inf.puc-rio.br/~roberto/docs/corosblp.pdf">原文</a>和<a href="http://www.cs.indiana.edu/~dyb/pubs/LaSC-7-1-pp83-110.pdf">HIEB 1994</a>两篇论文.</strong></p>




<h2>3. Programming With Lua Asymmetric Coroutines</h2>




<p>这一节我们从两个应用来围观Lua中非对称协程这一强大的特性: 生成器(generators)和协作式多任务(cooperative multitasking).</p>




<h3>3.1 生成器(generators)</h3>




<p>生成器就是用来产生值序列的工具, 每一次调用都返回一个新的值, 有一个典型的例子就是迭代器(iterator).</p>




<p><strong>demo1.lua</strong> : 二叉树的先序遍历</p>




<div class="highlight"><pre><code class="lua"><span class="c1">-- 三个叶子</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">d&quot;</span> <span class="p">}</span>
<span class="n">e</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">e&quot;</span> <span class="p">}</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">c&quot;</span> <span class="p">}</span>

<span class="c1">-- 三个内部节点</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">e</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">b&quot;</span> <span class="p">}</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">a&quot;</span> <span class="p">}</span>

<span class="c1">-- 先序遍历二叉树</span>
<span class="k">function</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">node</span> <span class="k">then</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c1">-- 迭代器</span>
<span class="k">function</span> <span class="nf">preorder_iterator</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">coroutine.wrap</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="n">preorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">-- 使用范型for</span>
<span class="n">seq</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">&quot;</span>
<span class="k">for</span> <span class="n">node</span> <span class="k">in</span> <span class="n">preorder_iterator</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">..</span> <span class="n">node</span> <span class="o">..</span> <span class="s2">&quot;</span><span class="s"> &quot;</span>
<span class="k">end</span>

<span class="c1">-- 打印结果为: d b e a c</span>
<span class="nb">print</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</code></pre></div>




<p>整个执行是这样的: preorder_iterator迭代器只会运行一次, 接下来范型for每一次都会调用由coroutine.wrap返回的函数(暂时称为f), 直到node为nil, 迭代结束. 而f的返回值由coroutine.yield带出来的, 因此print每次打印的都是node.key.</p>




<p><strong>我们再看一个例子</strong></p>




<p><strong>demo2.lua</strong>: 合并两棵二叉树</p>




<div class="highlight"><pre><code class="lua"><span class="c1">-- 第一棵树, root为a</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">d&quot;</span> <span class="p">}</span>
<span class="n">e</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">e&quot;</span> <span class="p">}</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">c&quot;</span> <span class="p">}</span>

<span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">e</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">b&quot;</span> <span class="p">}</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">a&quot;</span> <span class="p">}</span>

<span class="c1">-- 第二棵树, root为n</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">f&quot;</span> <span class="p">}</span>
<span class="n">h</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">h&quot;</span> <span class="p">}</span>
<span class="n">g</span> <span class="o">=</span> <span class="p">{</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">g&quot;</span> <span class="p">}</span>

<span class="n">m</span> <span class="o">=</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">h</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">m&quot;</span> <span class="p">}</span>
<span class="n">n</span> <span class="o">=</span> <span class="p">{</span> <span class="n">left</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">n&quot;</span> <span class="p">}</span>

<span class="k">function</span> <span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">node</span> <span class="k">then</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">key</span><span class="p">)</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span> <span class="nf">preorder_iterator</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">coroutine.wrap</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="n">preorder</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">function</span> <span class="nf">merge</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
    <span class="c1">-- 生成两个迭代器函数</span>
    <span class="kd">local</span> <span class="n">it1</span><span class="p">,</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">preorder_iterator</span><span class="p">(</span><span class="n">t1</span><span class="p">),</span>
                     <span class="n">preorder_iterator</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
    <span class="c1">-- 首先由迭代器分别从它们自己的树上吐出key</span>
    <span class="kd">local</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">it1</span><span class="p">(),</span> <span class="n">it2</span><span class="p">()</span>

    <span class="k">while</span> <span class="n">v1</span> <span class="ow">or</span> <span class="n">v2</span> <span class="k">do</span>
        <span class="c1">-- 比较这两棵树上的key的大小, 优先输出小的</span>
        <span class="k">if</span> <span class="n">v1</span> <span class="o">~=</span> <span class="kc">nil</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="ow">or</span> <span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">then</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">it1</span><span class="p">()</span>
        <span class="k">else</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">v2</span><span class="p">);</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">it2</span><span class="p">()</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="n">merge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- 输出结果为d b e a c g n f m n</span>
</code></pre></div>




<p>生成器(generators)还可以用于面向目的的编程(goal-oranted programming), 比如编写类似于<a href="http://zh.wikipedia.org/zh-cn/Prolog">Prolog</a>查询或者模式匹配的时候, 你不需要知道怎么去做, 你只要制定一个目标, 接下来让计算机帮你找到这个目标.其实这是通过回溯来完成的.</p>




<h3>3.2 User-Level Multitasking</h3>




<p>用协程来完成并行一开始是在Modula-2语言中, 但是后来由于线程(threads)的出现, 协程就被人们忽略了.</p>




<p>但是使用协程来完成并发任务的语言并不需要额外的数据结构来保证数据的一致性, 这个和基于抢占的多任务不同, 协程提供的并发机制叫做协作多任务.也就是当你不需要使用资源的时候就挂起自己来让别的人来使用.</p>




<p>编写多线程应用程序确实不是一个简单的任务, 特别是在某些环境中, 比如操作系统, 实时应用程序等, 它们对实时性要求特别高, 基于抢占的多任务就很难做到了.它们往往要考虑如何制定完善的同步策略, 再加上很多的开发者并没有多少并发编程的经验, 这个就有点像&lt;&lt;人月神话>>了, 系统越大, 问题越大.协作式多任务消除了这种冲突, 最小化同步的消耗, 看起来更适合!</p>




<p>在Lua中使用coroutine完成这样的工作很直接, 也很简单.每当我们创建一个新的task, 它就会被插入到任务列表中, 然后一个简单的任务调度器将不断的迭代这个任务表, 不断的运行每一个任务, 移除那些完成了的任务.</p>




<p>唯一的一个缺点是在使用阻塞操作的时候, 比如调用I/O操作阻塞的时候, 这个时候程序无法主动调用yield, 那么整个进程将发生阻塞直到I/O操作完成, 当然这个也很好解决, 只需要引入一个非阻塞的库即可.</p>




<h2>4. Coroutines in Programming Language（其它语言的Coroutines)</h2>




<ul>
<li>最广为人知的支持协程的语言就是Simula, 而且它还引入了对称协程(semi coroutine), 反正极其复杂~</li>
<li>70年代被广泛使用的BCPL语言(C语言的祖先), 也是一个典型的例子, 和Simula一样, BCPL也支持两种协程.</li>
<li>Modula2</li>
<li>最先提出迭代器的是CLU语言, 但是局限性很多. 受到CLU的启发, <a href="http://en.wikipedia.org/wiki/Sather">sather</a>也实现了迭代器, 但是在当时复杂的想合并二叉树这种应用还是没法解决的.</li>
<li>Python和Perl6</li>
<li><a href="http://www.stackless.com/">Stackless Python</a></li>
<li><a href="http://www.cs.arizona.edu/icon/">Icon Language</a></li>
</ul>




<h2>5. 总结</h2>




<p>本文主要介绍了Lua语言中的非对称协程, 说明了它的用法.也展示了其它的例如generators、回溯、多任务中的使用, 我们发现这些技术在非对称协程中很容易表达, 其实这并不是巧合, 事实上<a href="http://en.wikipedia.org/wiki/Delimited_continuation">partial continuations</a>和asymmeric coroutine在很多地方都是相似的.</p>




<p>虽然continuation这一概念表达能力很强, 但是它仍然很难让人理解, 特别是在面向过程的编程中, 而asymmeric coroutine也有着相同的能力, 但是却可以很容易的在面向过程式编程中让人理解.</p>




<p><strong>最后我们实现一下对称协程</strong></p>




<div class="highlight"><pre><code class="lua"><span class="n">coro</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">coro</span><span class="p">.</span><span class="n">main</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span> <span class="k">end</span>
<span class="n">coro</span><span class="p">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">coro</span><span class="p">.</span><span class="n">main</span>

<span class="c1">-- create a new coroutine</span>
<span class="k">function</span> <span class="nc">coro</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">coroutine.wrap</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">-- transfer control to a coroutine</span>
<span class="k">function</span> <span class="nc">coro</span><span class="p">.</span><span class="nf">trasnfer</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coro</span><span class="p">.</span><span class="n">current</span> <span class="o">~=</span> <span class="n">coro</span><span class="p">.</span><span class="n">main</span> <span class="k">then</span>
        <span class="k">return</span> <span class="nb">coroutine.yield</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="c1">-- dispatching loop(excutes in main program)</span>
        <span class="k">while</span> <span class="n">k</span> <span class="k">do</span>
            <span class="n">coro</span><span class="p">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">coro</span><span class="p">.</span><span class="n">main</span> <span class="k">then</span>
                <span class="k">return</span> <span class="n">val</span>
            <span class="k">end</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">k</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="nb">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">coroutine ended without trasnfering control...&quot;</span><span class="p">)</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>




<h2>6. 参考 &amp; 资料</h2>




<ul>
<li><a href="http://www.inf.puc-rio.br/~roberto/docs/">Roberto(Lua作者之一)公开的一些Lua资料</a> 重点是这两篇: 1. <a href="http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf">Revisiting Coroutines</a> 2. <a href="http://www.inf.puc-rio.br/~roberto/docs/corosblp.pdf">Coroutines in Lua</a></li>
<li><a href="http://blog.codingnow.com/2010/06/masterminds_of_programming_7_lua.html">采访 Lua 发明人的一篇文章</a></li>
<li><a href="http://en.wikipedia.org/wiki/Continuation">Continuation</a></li>
<li><a href="http://en.wikipedia.org/wiki/Continuation_passing_style">CSP</a></li>
<li><a href="http://en.wikipedia.org/wiki/Delimited_continuation">Delimited continuation</a></li>
<li><a href="http://en.wikipedia.org/wiki/First-class_citizen">first-class</a> 本文first-class object翻译应该为第一类对象</li>
<li><a href="http://www.cs.arizona.edu/icon/">the Icon Programming Language</a></li>
<li><a href="http://www.stackless.com/">Python Stackless</a></li>
<li><a href="http://en.wikipedia.org/wiki/Sather">Sather Programming Language</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/Prolog">Prolog 逻辑编程语言</a></li>
<li><a href="http://www.cs.indiana.edu/~dyb/pubs/LaSC-7-1-pp83-110.pdf">Subcontinuations</a> Subcontinuations在文中出现了多次, 不太理解, 这个是出处</li>
<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">C语言的协程</a></li>
<li><a href="http://swtch.com/libtask/">libtask</a> 一个协程库, C 语言</li>
<li><a href="http://www.xmailserver.org/libpcl.html">libpcl</a> 同样的, C语言协程library</li>
<li>关于范型for还是推荐<a href="http://www.lua.org/pil/7.html">Programming in Lua: Generic for</a></li>
</ul>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;如何交换两个数&lt;/title&gt;
  &lt;link href="/2013/01/c-swap-two-variable/"/&gt;
  &lt;pubDate&gt;2013-01-09T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2013/01/c-swap-two-variable&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;h2&gt;1. 故事是这样的&lt;/h2&gt;
</code></pre>

<p>这次发现源于写一个全排列生成器, 很容易做到的办法当然是使用递推关系: n个数的全排列等于n个{n-1}个数全排列之和.
于是用lua开始写了:</p>




<div class="highlight"><pre><code class="lua"><span class="c1">-- 全排列生成器</span>
<span class="k">function</span> <span class="nf">permgen</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">then</span>
       <span class="n">printResult</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span>
       <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="k">do</span>
           <span class="cm">--[[ n个数的全排列可以看作是n个{剩下n-1个数}的全排列.</span>
<span class="cm">               然后递归即可</span>
<span class="cm">          --]]</span>
           <span class="c1">-- put i-th element as the last one</span>
           <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
           <span class="c1">-- generate all permutations of the other elements</span>
           <span class="n">permgen</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
           <span class="c1">-- restore i-th element</span>
           <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
       <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
 
<span class="k">function</span> <span class="nf">printResult</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">do</span>
       <span class="nb">io.write</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;</span><span class="s"> &quot;</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="nb">io.write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="k">end</span>
 
<span class="n">permgen</span> <span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div>




<p>当然OK了, 然后我想还是用C写一个然后Lua调用玩玩.</p>




<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Set</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Set_t</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">printSet</span><span class="p">(</span><span class="n">Set_t</span> <span class="o">*</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%2d &quot;</span><span class="p">,</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pergen</span><span class="p">(</span><span class="n">Set_t</span> <span class="o">*</span><span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define SWAP(x, y) x = x - y; y = y + x; x = y - x;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printSet</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 1. swp</span>
        <span class="n">SWAP</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="c1">// 2. 生成这n-1个数的全排列</span>
        <span class="n">pergen</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="c1">// 3. 还原这个Set</span>
        <span class="n">SWAP</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">Set_t</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">S</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">S</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    
    <span class="n">S</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">S</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">S</span><span class="p">.</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    
    <span class="n">pergen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>




<p><strong>一模一样的啊, 可是编译怎么会这样???</strong></p>




<div class="highlight"><pre><code class="bash">van9ogh@VAN9OGH <span class="nv">$ </span>./a.out 
 0  2  3 
 0  0  3 
 0  0  3 
 0  0  3 
 0  0  0 
 0  0  0 
</code></pre></div>




<p>最后终于发现, 原来这个版本的swap, 不能交换swap(x, x), 而且x, y异号时容易溢出.</p>




<h2>2. 如何交换两个数</h2>




<p>以前看谭浩强那本C语言书的时候发现<strong>用异或操作可以不用第三个变量就交换两个数</strong>, 后来学习算法的时候又学会了一种, 到目前为止, 我可以写出四种原理不同的swap.</p>




<h3>1. 普通的方法(不写了, 相信你能想到)</h3>




<h3>2. 异或版本</h3>




<p>异或版本的本质是通过比较a和b的差异然后存储在某一个变量中, 于是在我手中的是一个差异和某一个变量, 那么我就可以还原出来另一个变量.这个让我想起了SVN等基于差异的版本控制系统, 以及图像处理中的优化, 通过比较差异我们这个原理我们可以做很多的事情.</p>




<p><strong>局限性</strong>: swap(&amp;x, &amp;x)是不行的</p>




<div class="highlight"><pre><code class="c"><span class="c1">// 1. 写法1</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">^</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">// 2. 写法2</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">^</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">^</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div>




<h3>3. 相减, 相加版本</h3>




<ol>
<li>如果知道了a+b和a那么我就知道b</li>
<li>如果知道了a-b和a那么我也知道b</li>
</ol>




<p><strong>局限性</strong>: swap(&amp;x, &amp;x)是不行的, 另外对于a+b版本, a和b同号会溢出, 对于a-b版本, a和b异号会溢出.(这个很好想, 因为一个变量容纳不了它们之和)</p>




<p><strong>a+b</strong>版本</p>




<div class="highlight"><pre><code class="c"><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div>




<p><strong>a-b</strong>版本</p>




<div class="highlight"><pre><code class="c"><span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div>




<h3>4. 利用运算符的优先级, 一行就够了!</h3>




<div class="highlight"><pre><code class="c"><span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">);</span>
</code></pre></div>




<p>这行代码实在是很难让人理解, 我们先看汇编之后的结果:</p>




<p><strong>test.c</strong></p>




<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>




<p><strong>test.i</strong></p>




<div class="highlight"><pre><code class="text"> .globl  main
main:
;--------------------------------------------------
    ; 前三行是在函数开始时候很典型的代码
    ; 1. 保存ebp寄存器
    pushl   %ebp
    ; 2. 将当前栈指针esp赋值给ebp
    movl    %esp, %ebp
    ; 3. 调整栈指针, 向下移动16个字节, 给局部变量留出空间
    subl    $16, %esp
;--------------------------------------------------
    ; 下面5行用来初始化
    ; 将10赋值给 %ebp - 8的位置
    movl    $10, -8(%ebp)
    ; 将20赋值给 %ebp - 4的位置
    movl    $20, -4(%ebp)
    ; 将%ebp - 4 中的数字(也就是20)赋值给寄存器eax
    movl    -4(%ebp), %eax
    ; 将%ebp - 8 中的数字(也就是10)赋值给寄存器edx
    movl    -8(%ebp), %edx
;--------------------------------------------------
    ; 先计算p = p+q-(p = q)中的p+q部分
    ; 10+20结果保存在edx中 (%edx) = 30
    addl    %eax, %edx

;--------------------------------------------------
    ; 再计算p = p+q-(p = q)中p=q的部分
    ; 将%eax寄存器中的值再次赋值为10
    movl    -8(%ebp), %eax
    ; 将%ebp - 4 位置的值修改为10
    movl    %eax, -4(%ebp)
;--------------------------------------------------
    ; 然后计算两个部分之差
    ; 将%eax中的值修改为%edx中的30
    movl    %edx, %eax
    ; 后面的减去前面的结果赋值给%eax, 30-10=20, %eax中的值为20
    subl    -4(%ebp), %eax
;--------------------------------------------------
    ; 最后在执行最左边的赋值
    ; 将%eax中的20赋值给%ebp-8
    movl    %eax, -8(%ebp)
;--------------------------------------------------
    ; 将%eax归零
    movl    $0, %eax

    ; 返回, 最终%ebp - 8 地址内的值为20
    ;           %ebp - 4 地址内的值为10
    leave
    ret
</code></pre></div>




<p>每一行的意思都写出来了, 最终完成了交换, 奇怪的是我们并没有通过什么差异的思想来交换啊, 为什么也能够交换呢, 这个和C语言的结合顺序有关, 对于p+q - (p = q), 先计算的是p+q, 然后再计算(p=q), 因此p并没有丢失, 最终还在寄存器中存着呢!</p>




<p>这个虽然没有swap(&amp;x, &amp;x)的局限性, 但是还是存在溢出的风险.以及编译器实现上的差异导致的问题, 因此把玩把玩即可, 千万不要用在项目中, 其实还是常规的思路最靠谱!</p>




<h2>3. 参考</h2>




<p><a href="http://stallman.blogbus.com/logs/18582675.html">AT&amp;T Assembly :HelloWorld.s</a> 介绍了一点汇编知识, 写的不错!</p>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;Lua学习笔记(1)&lt;/title&gt;
  &lt;link href="/2013/01/lua-oop/"/&gt;
  &lt;pubDate&gt;2013-01-05T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2013/01/lua-oop&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;p&gt;今天确实看了相当多的概念, 堆栈快溢出了;-) 从&lt;a href="https://github.com/cloudwu/skynet"&gt;skynet&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Domain-specific_language"&gt;DSL&lt;/a&gt;, &lt;a href="http://www.w3school.com.cn/xsl/index.asp"&gt;XSLT&lt;/a&gt;, 元编程, Lua Coroutine, lua_next, lua stack, 并行状态机(psm), 到&lt;a href="http://zh.wikipedia.org/zh-cn/MUD"&gt;MUD&lt;/a&gt;, &lt;a href="http://zguide.zeromq.org/page:all"&gt;zeroMQ&lt;/a&gt;, &lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt;, Lua oop 等等. 本来打算开始看Lua源码的, 不过走到这里才发现还是从熟悉语言本身开始.&lt;/p&gt;
</code></pre>

<h2>值得写下来的几点有:</h2>




<ul>
<li>lua_next函数</li>
<li>并行状态机</li>
<li>元编程</li>
<li>Lua中冒号和‘.’的区别</li>
</ul>




<h2>1. lua_next函数</h2>




<p>这个函数确实花费了我一些时间的. lua中有时候压栈的是一个table, 由于table本身有很多的类型, 虽然lua C API提供了众多的操作栈的函数, 但是设计者还是再添一笔, 这就是lua_next, 这个函数的执行逻辑是这样的:</p>




<p>除了<strong>// do something</strong> 那部分, 剩下的整个构成了函数lua_next</p>




<div class="highlight"><pre><code class="text">while (弹出key) {
        压入table中下一个key 和 value 两个
        
        // do something

        弹出value
    }
</code></pre></div>




<p>由于一开始需要弹出一个key, 于是通常情况下我们需要预先压入一个nil, 然后再操作, 连起来就是这样:</p>




<div class="highlight"><pre><code class="c">     <span class="c1">// 初始栈: [ table ], table: { name = &quot;LiuPeng&quot;, id = 1 }</span>
     <span class="n">lua_pushnil</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>  <span class="cm">/* first key */</span>
     <span class="cm">/* 第二个参数指的是table在栈中的位置</span>
<span class="cm">       这里我们假设栈中为[ table, nil ],</span>
<span class="cm">       这时1和-2是一个意思</span>
<span class="cm">     */</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">lua_next</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 也可以写成 : while(lua_next(L, -2) != 0) {</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s - %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
              <span class="n">lua_typename</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">lua_type</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)),</span>
              <span class="n">lua_typename</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">lua_type</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)));</span>
       <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
     <span class="p">}</span>
</code></pre></div>




<p>事实上table本身并没有发生变化, 迭代完成和栈又恢复原状: [ table ]</p>




<p><strong>我们来一个完整的demo</strong></p>




<p>lua_next.c</p>




<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;lua.h&gt;</span>
<span class="cp">#include &lt;lualib.h&gt;</span>
<span class="cp">#include &lt;lauxlib.h&gt;</span>

<span class="cp">#define STACKSCREENSHOT(Code) (Code), _StackPrint(L)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">_StackPrint</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">J</span><span class="p">,</span> <span class="n">nElements</span> <span class="o">=</span> <span class="n">lua_gettop</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>   <span class="c1">// 获得当前栈的elements个数</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; nElements = %d, [ &quot;</span><span class="p">,</span> <span class="n">nElements</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">J</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">J</span> <span class="o">&lt;=</span> <span class="n">nElements</span><span class="p">;</span> <span class="n">J</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lua_isnil</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">J</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot; - &quot;</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot; %s &quot;</span><span class="p">,</span> <span class="n">lua_typename</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">lua_type</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">J</span><span class="p">)));</span>
            <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; ]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 完整的lua_next描述为:</span>

<span class="cm">   while (弹出key) {</span>
<span class="cm">       压入table中下一个key &amp; value</span>
<span class="cm">       </span>
<span class="cm">       // do something</span>

<span class="cm">       弹出value</span>
<span class="cm">   }</span>
<span class="cm">*/</span>

<span class="kt">int</span> <span class="nf">table_next</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">k</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lua_next</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
        <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t_idx</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">luaL_newstate</span><span class="p">();</span>
    <span class="n">luaL_openlibs</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    <span class="n">luaL_loadfile</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;test.lua&quot;</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">lua_pcall</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;x = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

    <span class="n">lua_getglobal</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;testtab&quot;</span><span class="p">);</span>
    <span class="n">t_idx</span> <span class="o">=</span> <span class="n">lua_gettop</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    <span class="n">lua_pushnil</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    <span class="n">STACKSCREENSHOT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">table_next</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">STACKSCREENSHOT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Settings[%s] = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;--------------------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">lua_pushnil</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    <span class="n">STACKSCREENSHOT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">table_next</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">STACKSCREENSHOT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Settings[%s] = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">STACKSCREENSHOT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">lua_close</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>




<p><strong>test.lua</strong></p>




<div class="highlight"><pre><code class="lua"><span class="n">testtab</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">MsgCode</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">1&quot;</span><span class="p">,</span>
    <span class="n">Host</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">127.0.0.1&quot;</span><span class="p">,</span>
    <span class="n">abc</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">test&quot;</span><span class="p">,</span>
    <span class="n">id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span class="p">}</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">ok&quot;</span><span class="p">)</span>
</code></pre></div>




<h2>2. 并行状态机psm</h2>




<p>以前写web服务器的时候就对epoll+状态机感到头疼, 因为有时候会出现递归调用, 加上锁、内存管理, 会发现即使有valgrind这样的好工具, 依旧难办, 不过今天不是讨论这个的, 我们来看一个新奇的概念:并行状态机, 也就是在状态机中出现多个状态同时执行, 其实只要用多进程fork就可以办到.我写了一个C版本的.</p>




<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>

<span class="cp">#define SHOW() printf(&quot;[DEBUG] %d show input: %c\n&quot;, __LINE__, input)</span>
<span class="cp">#define LISTEN (input = getchar()), getchar(); switch(input) {</span>

<span class="cp">#define END }</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">input</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">LISTEN</span>
            <span class="k">case</span> <span class="sc">&#39;A&#39;</span>:
                <span class="n">LISTEN</span>
                    <span class="k">case</span> <span class="sc">&#39;B&#39;</span>:
                        <span class="n">SHOW</span><span class="p">();</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">&#39;C&#39;</span>:
                        <span class="n">SHOW</span><span class="p">();</span>
                    <span class="k">case</span> <span class="sc">&#39;D&#39;</span>:
                        <span class="n">SHOW</span><span class="p">();</span>
                <span class="n">END</span>
                <span class="k">break</span><span class="p">;</span>  <span class="c1">// end A</span>
            <span class="k">case</span> <span class="sc">&#39;E&#39;</span>:
                <span class="n">SHOW</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="n">END</span>

        <span class="n">LISTEN</span>
            <span class="k">case</span> <span class="sc">&#39;F&#39;</span>:
                <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
                <span class="n">LISTEN</span>
                    <span class="k">case</span> <span class="sc">&#39;G&#39;</span>:
                        <span class="n">SHOW</span><span class="p">();</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">&#39;H&#39;</span>:
                        <span class="n">SHOW</span><span class="p">();</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="n">END</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// child exit</span>
            <span class="k">case</span> <span class="sc">&#39;I&#39;</span>:
                <span class="n">SHOW</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="n">END</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>




<p>可能一下子很难理解, 读者不必关心逻辑, 因为这只是举个例子, 我们关注fork的位置, 然后将代码编译运行看看结果.</p>




<div class="highlight"><pre><code class="bash">van9ogh@VAN9OGH <span class="nv">$ </span>./a.out 
A
B
<span class="o">[</span>DEBUG<span class="o">]</span> 20 show input: B
F
H
<span class="o">[</span>DEBUG<span class="o">]</span> 41 show input: H
<span class="o">[</span>DEBUG<span class="o">]</span> 46 show input: H
</code></pre></div>




<p>我们看到的是, 41， 46行代码同时执行了, 这只是一个思路, 供以后参考!!</p>




<h2>3. 元编程</h2>




<p>类似与道家认为的几大元素一样:金、木、水、火、土, 又或者原子一样, 我们的自然界表现虽然很丰富, 但是构建整个世界的基本物质就是这些, 编程语言也一样, 虽然语言本身可以做很强大的事情, 但是在当前这样的计算机体系结构下, 基本元素就那些, 虽然鸡生蛋、蛋生鸡很难有结果, 但我们可以理解为鸡和蛋就像量子的所说的叠加态一样, 它们是相互影响的.</p>




<p>对于元编程我的理解是能够重新定义基本操作的能力.c++的template, 重载, lua中的oop, <a href="http://manual.luaer.cn/2.8.html">元表</a>就是利用了这一特性.</p>




<h2>4. Lua中Colon(冒号)和dot(点)有什么区别</h2>




<p>最终我在<a href="http://book.luaer.cn/_96.htm">这里</a>发现了这一点, 简单点说lua用冒号隐藏了self参数, 方便了oop.</p>




<h2>5. 参考 &amp; 资料</h2>




<ul>
<li><a href="https://github.com/cloudwu/skynet">skynet</a></li>
<li><a href="http://www.w3school.com.cn/xsl/index.asp">XSLT</a> XSLT在XML中, 类似于CSS之于HTML</li>
<li><a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/MUD">MUD</a></li>
<li><a href="http://zguide.zeromq.org/page:all">zeroMQ</a></li>
<li><a href="http://redis.io/">Redis</a> key-value键值存储</li>
<li><a href="http://manual.luaer.cn/2.8.html">元表</a> Lua中对元表的介绍</li>
</ul>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;How to use Lua and C together&lt;/title&gt;
  &lt;link href="/2013/01/lua-and-c/"/&gt;
  &lt;pubDate&gt;2013-01-04T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2013/01/lua-and-c&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;p&gt;最近在学习Lua, 这是一门简单而又强大的脚本语言, Lua在11年6月份的时候曾经进入toibe前10名, 现在稳定在&lt;a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html"&gt;18名左右&lt;/a&gt;, 其实排名是无所谓的, 学习一门脚本语言的目的是对C语言的扩展和补充, 在做项目的过程中, 明显感觉到了单单使用C语言的不足. 本文主要是总结Lua和C语言怎样交互.我们关注的是:&lt;/p&gt;
</code></pre>

<blockquote><ul>
<li>在C中调用Lua</li>
<li>在Lua中调用C</li>
</ul>
</blockquote>




<p>简单的C调用Lua是不需要使用栈API的, 直接luaL_dofile(..)即可, 但是当我们需要将参数在两种语言之间传来传去的时候, 栈的功效就体现出来了, 我们可以理解为lua和C之间使用栈进行通信.而lua C API提供给了我们丰富的<a href="http://www.lua.org/manual/5.2/manual.html#4">接口</a>.</p>




<h2>1. 在C中调用Lua(embedding)</h2>




<h3>a) Demo1</h3>




<p><em>luadd.c</em></p>




<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;lua.h&gt;</span>
<span class="cp">#include &lt;lualib.h&gt;</span>
<span class="cp">#include &lt;lauxlib.h&gt;</span>

<span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">luaadd</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
    <span class="n">lua_getglobal</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;add&quot;</span><span class="p">);</span> <span class="c1">// 先将lua脚本中的add函数压栈</span>
    <span class="n">lua_pushnumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>    <span class="c1">// 再将两个参数压栈</span>
    <span class="n">lua_pushnumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">lua_call</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>       <span class="c1">// 调用lua脚本中的add函数, 2表示参数个数, 1表示结果个数</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">lua_tointeger</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 索引为-x表示栈顶的x位置, 索引为x表示栈底的x位置</span>
    <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>           <span class="c1">// 弹出1个元素, 1表示弹出的元素个数</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">luaL_newstate</span><span class="p">();</span>       <span class="c1">// 在lua5.2中不支持lua_open, 因此使用luaL_newstate()</span>
    <span class="n">luaL_openlibs</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>          <span class="c1">// 将lua标准库载入L</span>
    <span class="n">luaL_dofile</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;add.lua&quot;</span><span class="p">);</span> <span class="c1">// 载入并运行lua脚本add.lua</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">luaadd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>      <span class="c1">// 运行luaadd函数</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The sum is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
    <span class="n">lua_close</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>              <span class="c1">// 释放L</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>




<p><em>add.lua</em></p>




<div class="highlight"><pre><code class="lua"><span class="k">function</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="k">end</span>
</code></pre></div>




<p>编译</p>




<div class="highlight"><pre><code class="bash">van9ogh@VAN9OGH <span class="nv">$ </span>gcc luadd.c -llua -ldl -lm
van9ogh@VAN9OGH <span class="nv">$ </span>./a.out 
Hello World

The sum is 25
</code></pre></div>




<h3>b) Demo2</h3>




<p><em>test.c</em></p>




<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;lua.h&gt;</span>
<span class="cp">#include &lt;lualib.h&gt;</span>
<span class="cp">#include &lt;lauxlib.h&gt;</span>

<span class="c1">// 这种就是直接调用, 没有用到间接的函数包装</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span> <span class="o">=</span> <span class="n">luaL_newstate</span><span class="p">();</span>

    <span class="cm">/* 载入lua标准库 */</span>
    <span class="n">luaL_openlibs</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>

    <span class="cm">/* 正常情况下, lua_pcall和lua_call一样, 不同的</span>
<span class="cm">      是最后一个参数.其中第二个0表示返回值个数为0</span>
<span class="cm">      这句话是说:</span>
<span class="cm">        1. 正确情况下luaL_loadfile返回0, 并且执行lua_pcall</span>
<span class="cm">        2. 错误情况下, 直接运行{}块中Code</span>
<span class="cm">   */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">luaL_loadfile</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;test.lua&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">lua_pcall</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    
        <span class="cm">/* 错误会被压入栈顶, 不过需要将它转化为字符串 */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;error: %s&quot;</span><span class="p">,</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 将f函数入栈 */</span>
    <span class="n">lua_getglobal</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">);</span>

    <span class="cm">/* 检查入栈的是否为函数 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lua_isfunction</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 传入两个参数21, 31 */</span>
    <span class="n">lua_pushnumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
    <span class="n">lua_pushnumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>

    <span class="cm">/* 执行函数, 2表示有两个参数, 1表示有一个返回值, 0表示没有错误</span>
<span class="cm">      等价于lua_call */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lua_pcall</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;error running function `f&#39;: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 检查返回值是不是一个数字, 一旦lua_pcall运行完毕, 函数和另外的参数</span>
<span class="cm">      就被自动的弹出了栈, 因此栈中的内容将是返回值 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lua_isnumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;function `f&#39; must return a number</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 将栈顶中的内容转化为double */</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">lua_tonumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Result: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>

    <span class="cm">/* 弹出栈中一个元素 */</span>
    <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="cm">/* 释放L */</span>
    <span class="n">lua_close</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>




<p><em>test.lua</em></p>




<div class="highlight"><pre><code class="lua"><span class="k">function</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">math.sin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>




<h3>c) Demo3</h3>




<p><em>luatest.c</em></p>




<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;lua.h&gt;</span>
<span class="cp">#include &lt;lualib.h&gt;</span>
<span class="cp">#include &lt;lauxlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span> <span class="o">=</span> <span class="n">luaL_newstate</span><span class="p">();</span>

    <span class="n">luaL_openlibs</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>

    <span class="n">luaL_dofile</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;foo.lua&quot;</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Allright we are back in C.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">lua_close</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>




<p><em>foo.lua</em></p>




<div class="highlight"><pre><code class="lua"><span class="nb">io.write</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">Please enter your name: &quot;</span><span class="p">);</span>
<span class="n">name</span> <span class="o">=</span> <span class="nb">io.read</span><span class="p">()</span> <span class="c1">-- read input from user</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">Hi &quot;</span> <span class="o">..</span> <span class="n">name</span> <span class="o">..</span> <span class="s2">&quot;</span><span class="s">, did you know we are in lua right now?&quot;</span><span class="p">)</span>
</code></pre></div>




<p>如果编译出现问题, 主要存在以下几点:</p>




<ol>
<li>本文针对lua5.2, lua5.1中应该将luaL_newstate()改为lua_open()</li>
<li>lua中需要环境变量LUA_DIR, LUA_CPATH, LUA_PATH, 如果没有设置可以参考:</li>
<li>上面编译时添加的选项-ldl, -lm, -llua不要少</li>
</ol>




<p><em>.bashrc</em></p>




<div class="highlight"><pre><code class="bash"><span class="nb">export </span><span class="nv">LUA_DIR</span><span class="o">=</span><span class="s2">&quot;/usr/local/lib/lua/5.2&quot;</span>
<span class="nb">export </span><span class="nv">LUA_CPATH</span><span class="o">=</span><span class="s2">&quot;?.so;$LUA_DIR/?.so&quot;</span>
<span class="nb">export </span><span class="nv">LUA_PATH</span><span class="o">=</span><span class="s2">&quot;?.lua;$LUA_DIR/?.lua&quot;</span>
</code></pre></div>




<h2>2. 在Lua中调用C函数(expanding)</h2>




<p>其实要想让Lua能够调用C函数, 按照常理我们需要将C代码编译成.so文件, 然后用Lua加载即可, 事实上Lua也是这么做的, 有几个关键函数需要说明:</p>




<ul>
<li><strong>声明</strong></li>
</ul>




<div class="highlight"><pre><code class="c"><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lua_CFunction</span><span class="p">)</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">);</span>
</code></pre></div>




<ul>
<li><strong>注册</strong></li>
</ul>




<div class="highlight"><pre><code class="c"><span class="c1">// 第三个参数是一个lua_CFunction函数指针</span>
<span class="kt">void</span> <span class="nf">lua_register</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span>
                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                   <span class="n">lua_CFunction</span> <span class="n">f</span><span class="p">);</span>


<span class="c1">// 第三个参数是一个struct</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">luaL_Reg</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="n">lua_CFunction</span> <span class="n">func</span><span class="p">;</span>
<span class="p">}</span> <span class="n">luaL_Reg</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">luaL_register</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">libname</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">luaL_Reg</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
</code></pre></div>




<ul>
<li><strong>查询</strong></li>
</ul>




<div class="highlight"><pre><code class="c"><span class="c1">// 这个函数用户dlopen查询, 用户只需要按照这个格式书写, 最后的命名也要是XXX.so</span>
<span class="kt">int</span> <span class="n">luaopen_XXX</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span>
</code></pre></div>




<h3>a) Demo1</h3>




<p><em>sayhello.c</em></p>




<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;lua.h&gt;</span>
<span class="cp">#include &lt;lualib.h&gt;</span>
<span class="cp">#include &lt;lauxlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">_SayHelloWorld</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span>
<span class="p">{</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nArgs</span> <span class="o">=</span> <span class="n">lua_gettop</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">nArgs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;2013&quot;</span><span class="p">);</span>
    <span class="n">lua_pushstring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;0101&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">luaopen_sayhello</span><span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lua_register</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot;sayhello&quot;</span><span class="p">,</span> <span class="n">_SayHelloWorld</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>




<p><em>sayhello.lua</em></p>




<div class="highlight"><pre><code class="lua"><span class="nb">require</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">sayhello&quot;</span><span class="p">)</span>

<span class="n">time1</span><span class="p">,</span> <span class="n">time2</span> <span class="o">=</span> <span class="n">sayhello</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">LiuPeng&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">time1</span><span class="p">,</span> <span class="n">time2</span><span class="p">)</span>
</code></pre></div>




<p><strong>编译</strong></p>




<div class="highlight"><pre><code class="bash">van9ogh@VAN9OGH <span class="nv">$ </span>gcc -o sayhello.so sayhello.c -shared -llua -ldl -lm
van9ogh@VAN9OGH <span class="nv">$ </span>lua sayhello.lua
LiuPeng Hello World!
2013    0101
</code></pre></div>




<p>很好用吧~</p>




<h2>3. 总结</h2>




<p>lua很容易嵌入C/C++, 它使用了栈来让脚本语言和C/C++通信, 因此学习lua我们应该了解lua C API的使用, 这样将帮助我们expanding和embedding这门语言, expanding注重将底层C/C++实现的各种功能由lua来调用, 而embedding注重的是在C/C++语言中调用lua, 比如说nginx的lua模块就是干这个的, 这样的好处是我们可以用脚本来无限扩展程序的逻辑, 缺点是底层代码依赖于上层的脚本, 这也就是为什么lua在embedding中会处于完胜的地位, 因为它足够小, 那么这个缺点很大程度上被掩盖, 相比与那些大而全的语言如python, 最近正好要将smartwin的项目GSM接收模块进行重写, 希望Lua能够帮到忙.</p>




<h2>4. 参考&amp;资料</h2>




<ul>
<li><a href="http://en.wikipedia.org/wiki/Lua_programming_language#Stack">lua wiki stack部分</a></li>
<li><a href="http://twistedmatrix.com/users/glyph/rant/extendit.html">Extending Vs. Embedding</a> Python更适合expanding而Lua两者是兼备的.</li>
<li><a href="http://lua-users.org/wiki/LuaVersusPython">Lua Versus Python</a></li>
<li><a href="http://docs.python.org/2/extending/index.html">Extending and Embedding the Python Interpreter</a></li>
<li><a href="http://www.swig.org/Doc1.3/Lua.html">SWIG and Lua</a> 有时候还是需要SWIG的, 特别是大规模自动化任务</li>
<li><a href="http://julien.danjou.info/blog/2011/why-not-lua">Why not Lua </a> 忠言逆耳</li>
<li><a href="http://findfunaax.com/notes/file/82">Lua 栈操作</a></li>
<li><a href="http://www.lua.org/manual/5.2/manual.html">lua5.2 manual</a></li>
<li><a href="http://www.lua.org/manual/5.1/manual.html">lua5.1 manual</a></li>
<li><a href="http://gamedevgeek.com/tutorials/calling-c-functions-from-lua/">Calling C++ Functions From Lua</a></li>
<li><a href="http://code.google.com/p/zester/wiki/Lua_C">How to use Lua and C together</a></li>
<li><a href="http://www.gamedev.net/page/resources/_/technical/game-programming/an-introduction-to-lua-r1932">lua introduction(注意stack部分)</a></li>
<li><a href="http://www.lua.org/pil/index.html">Programming in Lua5.1</a></li>
<li><a href="http://lua-users.org/wiki/BuildingModules">Building Modules</a></li>
<li><a href="http://book.luaer.cn">lua5.1编程(中文)</a></li>
<li><a href="http://www.codingnow.com/temp/readinglua.pdf">云风Lua5.2源码欣赏</a> 这个很难得, 推荐!</li>
</ul>




<h2>5. 代码下载<a href="/code/lua/lua-c-allinone.tar.gz">allinone.tar.gz</a></h2>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;jekyll&lt;/title&gt;
  &lt;link href="/2012/12/markdown/"/&gt;
  &lt;pubDate&gt;2012-12-31T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2012/12/markdown&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;h3&gt;Background&lt;/h3&gt;
</code></pre>

<p>这次将博客进行了改版, 还是使用jekyll, 看来程序员都喜欢trade-off :) 这次主要比较了reStructedText、Textile、Markdown等标记语言, 对语法高亮进行了调整, 这个过程让我对jekyll的工作机制有了一些了解。学习了很多新的名词: liquid,       YAML Front Matter, R, lyx, pygments, rdiscount, redcarpet等等.</p>




<p>ruby的世界真的很奇特, 对于我这个古老的C程序员确实需要适应, 按照我的逻辑, 完成这样一个可以通过设计博客模版然后专心写txt文件, 用Git管理站点的方式, 确实是一个浩大的工程(关注的方方面面颇多):模版、标记语言、插件管理、版本控制, 如果都是C语言来写, 可能要吐血.</p>




<p>jekyll的核心其实就是上面说到的几个方面, 但它更像是一个裁缝, 因为开源社区已经做的很好了.</p>




<blockquote><ul>
<li>模版引擎

<ul>
<li>liquid</li>
</ul>
</li>
<li>标记语言:

<ul>
<li>markdown</li>
<li>textile</li>
</ul>
</li>
<li>语法高亮

<ul>
<li>pygments</li>
</ul>
</li>
<li>版本控制

<ul>
<li>Git</li>
</ul>
</li>
</ul>
</blockquote>




<p>而且ruby本身又有内置的web服务器, 因此其实工具已经不缺了, 然后大家的需求是一个很灵活的带版本控制的静态博客站点, 于是jekyll将用户写的带标记的txt(可看作是数据流), 经过上面这些工具的颠三倒四的折疼, 输出了一个static site!</p>




<h3>模版引擎: Liquid template engine</h3>




<p>在使用语法高亮的时候我们会这么写:{<em>% highlight cpp </em>%}, 这个就是liquid模板引擎的语法, jekyll的liquid tags我们我们看<a href="https://github.com/mojombo/jekyll/wiki/Template-Data">这里</a>, 和<a href="https://github.com/mojombo/jekyll/wiki/liquid-extensions">这里</a>比如本博客的index.md、<em>layouts/page.html、</em>layouts/post.html就是模版.</p>




<h3>轻量级标记语言: Light Markup Language</h3>




<p>其实标记语言并不是要和html语言比个高低, 提出它主要是为了方便我们去编写文档, 因为html页面虽然很强大, 但是那是有浏览器解析的结果, 背后的web代码既冗余又无法理解.轻量级的标记语言有很多, 不同的语言社区主推的都不一样, 比如python社区可能更熟悉reStructedText, jekyll没有去追求大而全, 它主要支持Markdown、textile. 这两种语言本身的解析器实现有很多, Wiki上有列举, 对于Markdown, 支持rdiscount、Marrku、redcarpet(jekyll 0.2.x), 对于textile, 支持redCloth.目前github通过扩展markdown, 推出的redcarpet貌似很流行(<a href="http://github.github.com/github-flavored-markdown/">GFM</a>), rdiscount也不错. 虽然Markdown支持者众多(可以看一下<a href="http://www.yangzhiping.com/tech/r-markdown-knitr.html">这里</a>, <a href="http://www.codinghorror.com/blog/2012/10/the-future-of-markdown.html">这里</a>) 但也有人为它担忧, 主要是太过简陋, 标准不一, 读者可以看一下<a href="http://blog.liancheng.info/why-i-hate-markdown/#.UOFBNvLsOxI">这里</a>, 还有<a href="http://www.ituring.com.cn/article/8648">这里</a>.笔者最终选择的是rdiscount解析器, 它是<a href="http://www.pell.portland.or.us/~orc/Code/discount/">discount</a>的ruby实现.</p>




<h3>语法高亮: pygments</h3>




<p>笔者一开始认为语法高亮是使用什么js做的, 后来怎么也找不到highlight.js, 倒是找到了highlight.css, 甚是诧异, 虽然语法高亮可以通过js来做, 而且有很多优秀的实现, 也都很强大.但其实jekyll是通过python的<a href="http://pygments.org/">pygments</a>来做的, 用户只需要载入相应的highlight.css样式给jekyll, 它就可以对相应的block进行代码高亮了.于是我们只需要:{<em>% highlight </em>%} {<em>% endhighlight </em>%}, 代码就高亮了, 如果读者有兴趣, 可以下载<a href="https://github.com/mojombo/jekyll/tree/master/lib/jekyll">jekyll</a>代码,在jekyll/lib/jekyll/tags/highlight.rb中就可以看到这个调用过程了.</p>




<h3>总结</h3>




<p>其实静态网站生成工具有很多, 可以看看<a href="http://iwantmyname.com/blog/2011/02/list-static-website-generators.html">这里</a>, 还有<a href="http://www.mickgardner.com/2012/12/an-introduction-to-static-site.html">这篇</a>普及性的.从这样的工具的出现我们不难发现:</p>




<p><strong>我们都在慢慢的将Machine和人类能做的事情进行区分开来, Machine擅长重复性的, 程序化的工作, 而人类则更擅长创造性的、设计性的工作, 我们需要的是利用这一点, 帮助我们在苦短的人生中节约时间, 创造价值.</strong></p>




<p><strong>每一种语言都有它存在的道理, 脚本语言更擅长于处理string, 灵活性较高, 而底层的C语言更注重的是效率, 完成一些和操作系统密切相关的工作.因此我们不应该只学一门语言, 而要使用脚本语言帮我们完成日常的小任务, 使用底层语言帮我们处理效率上的问题, 遵循UNIX哲学, 通过组合而不是继承来解决问题!</strong></p>




<h3>参考文献</h3>




<p>有了上面的介绍, 我想对于搭建这样一个静态博客应该没有什么难度了:)下面推荐一些写的好的jekyll入门指导</p>




<h4>QuickStart</h4>




<blockquote><ul>
<li><a href="http://www.soimort.org/posts/101/">像黑客一样写博客——Jekyll入门</a></li>
<li><a href="https://github.com/mojombo/jekyll/wiki/Usage">Jekyll Usage</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">搭建一个免费的，无限流量的Blog----github Pages和Jekyll入门</a></li>
<li><a href="http://recursive-design.com/blog/2010/10/12/static-blogging-the-jekyll-way/">Static blogging the Jekyll way</a></li>
</ul>
</blockquote>




<h4>Markdown</h4>




<blockquote><ul>
<li><a href="http://www.worldhello.net/gotgithub/appendix/markups.html">worldHello</a></li>
<li><a href="http://wowubuntu.com/markdown">Markdown 语法说明 (简体中文版)</a></li>
<li><a href="http://daringfireball.net/projects/markdown/syntax">Markdown 语法说明 (English Edition)</a></li>
<li><a href="http://microjo.github.com/work/markdown_ext.html">python-markdown</a></li>
<li><a href="http://blog.yanxyz.net/php-markdown-extra-description.html#header-id">PHP Markdown Extra说明</a></li>
</ul>
</blockquote>




<h4>Liquid</h4>




<blockquote><ul>
<li><a href="http://robots.thoughtbot.com/post/159806314/custom-tags-in-liquid">Custom Tags in Liquid</a></li>
<li><a href="https://github.com/mojombo/jekyll/wiki/liquid-extensions">liquid-extensions</a></li>
</ul>
</blockquote>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;JavaScript入门经典读书笔记&lt;/title&gt;
  &lt;link href="/2012/12/Beginning-JavaScript-3rd-edition/"/&gt;
  &lt;pubDate&gt;2012-12-31T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2012/12/Beginning-JavaScript-3rd-edition&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;p&gt;最近刚好在迁移博客, 想解决博客的全文搜索问题, 当然最好是用JS来做啦, 况且我已经发现了使用JQuery做的demo, 于是翻来Beginning JavaScript, 了解一下, 其实一直想了解一下这门活在浏览器中的唯一语言, 它是怎么样和HTML, CSS结合起来, 将Web变得如此强大的.&lt;/p&gt;
</code></pre>

<h3>P0-173</h3>




<p>前面写的很好, 读的很快.基本上讲了基本的程序结构:循环、分支、顺序, 又提到了若干JS内置对象:Array, String, Data, Number, Math, 以及浏览器的文档对象模型DOM: window, history, location, navigator, screen, document.</p>




<h3>P173</h3>




<p>浏览器页面上每一个img对象都保存在images[]数组中, 对于页面上的第一副图片, 用数组document.images[0]表示, 以此类推.img对象的属性就包括src、id等等属性, 这样就将HTML标记语言中的属性和JS对象很好的结合在了一起!</p>




<h3>P248</h3>




<p>使用<frameset>来定义框架集, 使用<frame>来标记框架, 对于一个不包含框架的页面来说, 仅存在有一个window对象, 但对于包含框架集页面来说, 页面的每一个框架都具有一个相应的window对象.除了包含框架集的顶层窗口的window对象之外, 每一个框架的window对象都是其父框架的window对象的子对象.我想似乎可以利用这一点做一个dummy框架集, 隐藏起来, 帮我们记录一些信息.</p>




<h3>P268</h3>




<p>window对象的open()方法用来打开一个新的tab, 还可以返回这个新的tab的window对象引用, 关闭这个tab我们可以使用close()方法</p>




<h3>P275</h3>




<p>这一节讲到了一个重要的方法, 用于在打开一个新窗口以后, 新窗口和老窗口之间的通信.</p>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;TinyOS: MagXC.nc&lt;/title&gt;
  &lt;link href="/2012/12/tinyos-sensorboards-mts300cb-magx/"/&gt;
  &lt;pubDate&gt;2012-12-14T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2012/12/tinyos-sensorboards-mts300cb-magx&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;h2&gt;说明&lt;/h2&gt;
</code></pre>

<p>本来想继续翻译Philip Levis那篇文章的, 不过对于ADC其实我并不是太理解, 所以还是先探究一下tos/sensorboards/mts300下的组件.下面我们选择tos/sensorboards/mts300/MagXC.nc来探究一下, 看看到底为什么我们只需要call MagX.read数据就出来了?其实这中间走了许多层, 出现了若干我们未知的领域.分析完以后我们自己通过纯手写一个底层的nesC源代码烧到micaz节点上, 看看是不是和我们预期所想的一样. 我想这种探究还是很有意思的.</p>


<h3>MagXC.nc</h3>


<p>这是一个HIL层的地磁场传感器的读取接口, 用户只需要将read接口连接上去即可, 非常的易于使用, 我们先来看看内部的实现:</p>


<div class="highlight"><pre><code class="c"><span class="cp">#include &quot;mts300.h&quot;</span>

<span class="n">generic</span> <span class="n">configuration</span> <span class="nf">MagXC</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">provides</span> <span class="n">interface</span> <span class="n">Mag</span><span class="p">;</span>
  <span class="n">provides</span> <span class="n">interface</span> <span class="n">Read</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">UQ_MAG_RESOURCE</span><span class="p">)</span>
  <span class="p">};</span>
  
  <span class="n">components</span> <span class="n">MagReadP</span><span class="p">,</span><span class="n">MagConfigP</span><span class="p">,</span> <span class="n">new</span> <span class="n">AdcReadClientC</span><span class="p">()</span> <span class="n">as</span> <span class="n">AdcX</span><span class="p">;</span>

  <span class="n">Mag</span> <span class="o">=</span> <span class="n">MagReadP</span><span class="p">;</span>

  <span class="n">Read</span> <span class="o">=</span> <span class="n">MagReadP</span><span class="p">.</span><span class="n">MagX</span><span class="p">[</span><span class="n">ID</span><span class="p">];</span>
  <span class="n">MagReadP</span><span class="p">.</span><span class="n">ActualX</span><span class="p">[</span><span class="n">ID</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">AdcX</span><span class="p">;</span>
  <span class="n">AdcX</span><span class="p">.</span><span class="n">Atm128AdcConfig</span> <span class="o">-&gt;</span> <span class="n">MagConfigP</span><span class="p">.</span><span class="n">ConfigX</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>其实TinyOS的代码是很好理解的, 只是有时候会将初学者跳晕掉, 太多的配线了, 我们不理解的是为什么解决一个问题要这么麻烦, 干嘛搞这么多的配线啊.其实只要我们理解了这其中的模式, 知道了每一个组件所处的层次, 也就明了了:有时候不是非要这么多配线, 这就是设计层面上的优雅性了, 作者只是将功能很好的分了一个层次. 这样的设计到底好不好, 我们也无法评判, 毕竟传感器网络操作系统的设计, 没有什么可以借鉴的, 很多决策都是在不可预知的情况下作出的.扯远了.</p>


<p>我们发现这个组件内部全是configuration, 没有module, 那么说明这一层面上所需要的条件都已经具备了, 只需要配置一下就可以了, 不需要写真正的代码.因此写这样的代码就对读者提出了一个要求:你要明白你想要什么以及你通过什么达到这样的目的.这基本就是TinyOS接口所要表达的意思了.比如这个例子:我们希望能够读取这个传感器的数据, 而且最好还能对传感器获取传感器的一些设置.那么我们必须要找到这样功能的组件能提供类似于Read和Mag接口, 幸运的是这货还真有:MagReadP.nc但是新的问题出现了, 这个组件还需要配置接口ActualX, 如果我们查看这个组件内部, 发现其实这个组件只是帮我们解决了Mag接口的需求, 但是Read接口它也不会, 它只是做了一个代理仍给了别人, 并且把它换了一个包装叫做:ActualX(还蛮真诚的), 那么到底谁会提供真正的读取传感器数据的功能呢?我们找到了AdcReadClientC.nc, 这下好了问题基本解决了, 只是这家伙还需要一个接口Atm128AdcConfig接口, 大概和芯片的配置有关, 我们得找找了, 幸好, 这就是MagConfigP.nc, 这个组件没有再uses什么其它的接口, 任务就完成了, 松了一口气.接下来实际上就是将我们找到的这些组件配在一起, 就OK了.</p>


<p>有些读者觉得这简直就在糊弄人, 这种分析方法只是自顶向下的, 前提是你必须是糕富帅, 你要什么有什么, 其实笔者只是提供了这样一个思路, 说明TinyOS的这种设计哲学, 这恰恰和真实社会的组织结构非常相似, 这就是社会分工, 每个人都或多或少的能够为别人提供一些服务, 同时他也需要借助别人的力量, 在TinyOS这个世界里, 我们就像BOSS一样, 我们有很多这样忠实的组件, 我们需要做的事情就是发挥BOSS的作用.读者如果从现实社会中走一遭, 或许会发现还是代码的世界乐趣多:), 其实相对于这些代码的复杂度是没法和现实社会的复杂度所相比的.因此我们不要抱怨学习一个新的工具又是一大陀文档啊什么的, 要从根本上热爱他们!比如tinyos的官方文档http://www.tinyos.net/tinyos-2.1.0/doc/nesdoc/micaz/, 其实每一个配线图都是一张社交图谱, 它们就活跃在你的眼皮底下, 不要错过他们!社会分工其实在什么年代都不会消亡, 即使在遥远的未来, 只是那时人换成了机器, 或许那时我们的文档上的组件换成了真正的AI机器, 程序员的编程方式发生了根本的改变.</p>


<p>从这个角度来说, 我们就不再困惑为什么配线图这么复杂, 也就明白了构建大型的软件是需要时间的, 可能包括一些重构, 我们要做的就是利用这种架构快速的开发自己的应用, 并在喝咖啡的时候, 从美学角度审视她, 观察她的每一个部分, 深入进去.我想这就是为什么对于一个设计的优美的软件系统程序员会发疯, 一旦理解了其中的精髓, 我们会被深深的迷住.</p>


<h3><span class="caps">ADC</span></h3>


<p>忘了我们今天的主题是讨论ADC, 我们继续:)</p>


<p>从上一段的讲述中我们得知MagXC.nc Read接口部分是AdcReadClientC.nc做的, 我们继续发现:</p>


<p>果不其然, 这个文件在tos/chips/atm128/adc中, 按照上一节的方法, 我们发现&quot;真正&quot;提供Read功能的组件来自WireAdcP.nc, 对于其它组件我们不再驻足观看, 而WireAdcP.nc的Read来自AdcP.nc, 然后发现AdcP.nc也是做了代理, 最终和两个文件相关:</p>


<p>Atm128AdcP.nc和HplAtm128AdcP.nc, 之所以不再说一个文件, 因为再继续查看下去会到达中断处理函数, 其实最终读取数据并不是都是那个函数在干, 还需要上一层的组件来配置一下寄存器, 或许还要开启一些中断, 基本上就是这样了, 接下来我们详细剖析这两个组件.</p>


<h3>Atm128AdcP.nc <span class="caps">AND</span> HplAtm128AdcP.nc</h3>


<p>我们来看核心代码:<br />
上层应用程序的Read需求经过层层代理转发, 到达了这一层的一个函数:(Atm128AdcP.nc), 我进行了注释.</p>


<div class="highlight"><pre><code class="c">    <span class="kt">void</span> <span class="nf">getData</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">refVoltage</span><span class="p">,</span> <span class="n">bool</span> <span class="n">leftJustify</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prescaler</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Atm128Admux_t</span> <span class="n">admux</span><span class="p">;</span>     <span class="c1">// ADMUX 寄存器</span>
            
        <span class="n">Atm128Adcsra_t</span> <span class="n">adcsr</span><span class="p">;</span>    <span class="c1">// ADCSR 寄存器</span>

        <span class="n">admux</span> <span class="o">=</span> <span class="n">call</span> <span class="n">HplAtm128Adc</span><span class="p">.</span><span class="n">getAdmux</span><span class="p">();</span>
        <span class="n">f</span><span class="p">.</span><span class="n">precise</span> <span class="o">=</span> <span class="n">isPrecise</span><span class="p">(</span><span class="n">admux</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">refVoltage</span><span class="p">);</span>
        <span class="n">f</span><span class="p">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>

        <span class="n">admux</span><span class="p">.</span><span class="n">refs</span> <span class="o">=</span> <span class="n">refVoltage</span><span class="p">;</span>
        <span class="n">admux</span><span class="p">.</span><span class="n">adlar</span> <span class="o">=</span> <span class="n">leftJustify</span><span class="p">;</span>
        <span class="n">admux</span><span class="p">.</span><span class="n">mux</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
        <span class="n">call</span> <span class="n">HplAtm128Adc</span><span class="p">.</span><span class="n">setAdmux</span><span class="p">(</span><span class="n">admux</span><span class="p">);</span>

        <span class="n">adcsr</span><span class="p">.</span><span class="n">aden</span> <span class="o">=</span> <span class="n">ATM128_ADC_ENABLE_ON</span><span class="p">;</span>
        <span class="n">adcsr</span><span class="p">.</span><span class="n">adsc</span> <span class="o">=</span> <span class="n">ATM128_ADC_START_CONVERSION_ON</span><span class="p">;</span>
        <span class="n">adcsr</span><span class="p">.</span><span class="n">adfr</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">multiple</span><span class="p">;</span>
        <span class="n">adcsr</span><span class="p">.</span><span class="n">adif</span> <span class="o">=</span> <span class="n">ATM128_ADC_INT_FLAG_ON</span><span class="p">;</span> <span class="c1">// clear any stale flag</span>
        <span class="n">adcsr</span><span class="p">.</span><span class="n">adie</span> <span class="o">=</span> <span class="n">ATM128_ADC_INT_ENABLE_ON</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prescaler</span> <span class="o">==</span> <span class="n">ATM128_ADC_PRESCALE</span><span class="p">)</span>
          <span class="n">prescaler</span> <span class="o">=</span> <span class="n">call</span> <span class="n">Atm128Calibrate</span><span class="p">.</span><span class="n">adcPrescaler</span><span class="p">();</span>
        <span class="n">adcsr</span><span class="p">.</span><span class="n">adps</span> <span class="o">=</span> <span class="n">prescaler</span><span class="p">;</span>
        <span class="n">call</span> <span class="n">HplAtm128Adc</span><span class="p">.</span><span class="n">setAdcsra</span><span class="p">(</span><span class="n">adcsr</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">async</span> <span class="n">command</span> <span class="n">bool</span> <span class="n">Atm128AdcSingle</span><span class="p">.</span><span class="n">getData</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">refVoltage</span><span class="p">,</span>
                         <span class="n">bool</span> <span class="n">leftJustify</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">prescaler</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">atomic</span>
      <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">getData</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">refVoltage</span><span class="p">,</span> <span class="n">leftJustify</span><span class="p">,</span> <span class="n">prescaler</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">.</span><span class="n">precise</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>


<p>在更底层的HplAtm128AdcP.nc我们又发现了中断处理函数:</p>


<div class="highlight"><pre><code class="c">    <span class="n">async</span> <span class="n">command</span> <span class="kt">uint16_t</span> <span class="n">HplAtm128Adc</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="n">ADC</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="cm">/* A/D interrupt handlers. Signals dataReady event with interrupts enabled */</span>
    <span class="n">AVR_ATOMIC_HANDLER</span><span class="p">(</span><span class="n">SIG_ADC</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">call</span> <span class="n">HplAtm128Adc</span><span class="p">.</span><span class="n">getValue</span><span class="p">();</span>
    
    <span class="n">__nesc_enable_interrupt</span><span class="p">();</span>
    <span class="n">signal</span> <span class="n">HplAtm128Adc</span><span class="p">.</span><span class="n">dataReady</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>


<p>使用avr128的ADC我们需要知道3个寄存器: ADMUX、ADCSRA、SIFOR, ADMUX主要用来设置一些参数,比如参考电压、对齐方式、模拟通道、增益选择.而ADCSRA寄存器主要是用来控制的, 比如使能啊, 中断啊什么的.还有SIFOR则是一个特殊功能寄存器, 主要用在快速ADC中.具体这三个寄存器各个位表示什么意思我就不一个一个说了大家可以去手册查询, 用起来是相当方便的, 一般而言你只需要设置好这三个寄存器, 然后就乖乖的等中断自己到来吧, 当然中断函数你得写好咯.有一个注意点是如果工作在非连续模式下, 转换结束我们要将ADCSRA寄存器的ADEN置为0关闭它, 等待下一次开启.(当然更严谨的还要设置其它位, 不过这个设置好就可以读取数据了).</p>


<p>参考我们的研究结果, 写一个一步到位的, 巩固一下. 也就是说我们要写驱动啦!</p>


<h3><span class="caps">ADC</span> 例子</h3>


<div class="highlight"><pre><code class="c"><span class="n">module</span> <span class="n">TempDeviceP</span> <span class="p">{</span>
    <span class="n">provides</span> <span class="n">interface</span> <span class="n">Read</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">as</span> <span class="n">Temp</span><span class="p">;</span>
    <span class="n">provides</span> <span class="n">interface</span> <span class="n">Init</span> <span class="n">as</span> <span class="n">SoftwareInit</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
    <span class="k">volatile</span> <span class="kt">uint16_t</span> <span class="n">data</span><span class="p">;</span>

    <span class="n">command</span> <span class="n">error_t</span> <span class="n">SoftwareInit</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 这里的两句话不是凭空出现的, 读者如果有crossbow的micaz节点</span>
        <span class="c1">// 和mts300cb传感器背板就知道了, PW0管脚是用来给温度传感器</span>
        <span class="c1">// 供电的!</span>
        <span class="n">DDRC</span>  <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>   <span class="c1">// PW0位设置为输出</span>
        <span class="n">PORTC</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>   <span class="c1">// PW0位设置为High</span>
        <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">command</span> <span class="n">error_t</span> <span class="n">Temp</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 这个是mica tempeature的配置</span>
        <span class="n">ADMUX</span> <span class="o">=</span> <span class="mh">0x21</span><span class="p">;</span>        <span class="c1">// 0010 0001</span>
                             <span class="c1">// 位7、6 REFS1~REFS0  : 00(以外部AREF为基准比较电压)</span>
                             <span class="c1">// 位5                 : 1 (左对齐)</span>
                             <span class="c1">// 位4~0 MUX4~MUX0     : 00001(channel1)</span>

        <span class="n">ADCSRA</span> <span class="o">=</span> <span class="mh">0xd8</span> <span class="o">|</span> <span class="n">ATM128_ADC_PRESCALE_2</span><span class="p">;</span>
                             <span class="c1">// 1101 1000</span>
                             <span class="c1">// 位7                 : 1 (ADC使能)</span>
                             <span class="c1">// 位6                 : 1 (开始转换)</span>
                             <span class="c1">// 位5                 : 0 (关闭连续工作模式)</span>
                             <span class="c1">// 位4                 : 1 (中断标志)</span>
                             <span class="c1">// 位3                 : 1  (中断使能)</span>
                             <span class="c1">// 位2,1,0             : 000 (不开预分频器)</span>

        <span class="n">SFIOR</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>        <span class="c1">// 不工作在快速模式下</span>

        <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">task</span> <span class="kt">void</span> <span class="n">dataReady</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">atomic</span> <span class="p">{</span>
            <span class="n">signal</span> <span class="n">Temp</span><span class="p">.</span><span class="n">readDone</span><span class="p">(</span><span class="n">SUCCESS</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">CLR_BIT</span><span class="p">(</span><span class="n">ADCSRA</span><span class="p">,</span> <span class="n">ADEN</span><span class="p">);</span>  <span class="c1">// 结束以后手动将ADCSRA的ADEN为置0</span>
    <span class="p">}</span>

    <span class="c1">// ADC中断处理函数, 这个是avr-gcc的写法, 后面的hwevent是nesc内部的</span>
    <span class="c1">// 编译器注释, 表示这是一个硬件中断, 这样它会相应的进行一些处理.</span>
    <span class="c1">// 再后面的@C()则表示这是一个C语言语句, nesc编译器不要对它进行重命名</span>
    <span class="kt">void</span> <span class="n">SIG_ADC</span><span class="p">()</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">interrupt</span><span class="p">))</span> <span class="err">@</span><span class="n">hwevent</span><span class="p">()</span> <span class="err">@</span><span class="n">C</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">atomic</span> <span class="p">{</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">ADC</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">post</span> <span class="n">dataReady</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p>用我的这个驱动, 我写了一个具体的, 读者可以将基站烧写为BaseStation, 然后将我的adc例子烧到另外一个节点上装上mts300cb传感器, 在pc机上用java net.tinyos.tools.Listen -comm serial@/dev/ttyUSB1:57600命令看看收到的结果, 当然这个adc还只是模拟值, 怎么变换大家自己去找公式咯.</p>


<ul>
    <li>[下载] <a href="/code/nesc/adc.tar.gz">adc.tar.gz</a></li>
</ul>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;Experiences from a Decade of TinyOS Development&lt;/title&gt;
  &lt;link href="/2012/12/experiences-from-a-decade-of-tinyos-development/"/&gt;
  &lt;pubDate&gt;2012-12-13T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2012/12/experiences-from-a-decade-of-tinyos-development&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;h3&gt;这是什么&lt;/h3&gt;
</code></pre>

<p>TinyOS作者之一:philip leveis对TinyOS操作系统10年的发展和展望, 笔者有幸发现这篇文章, 十分庆幸, 只能聆听大师的教诲了!以下是这篇文章的翻译.题目就不翻译了, 不想变了味道. 有些句子加入了自己的理解, 没有严格按照原句剖析主谓宾. 另外, 括号中大多是我个人的注解, 虽然注解多了, 是很令人反感的事情.花了5天终于完成了, 第一次翻译这么长的一篇论文, 总的来说, 对文章整体把握的能力还不是很到位, 因此会让读者有一种凌乱的感觉. 总之, 这个过程让我对TinyOS有了更深刻的认识!</p>


<h3>Let&#8217;s Begin!</h3>


<h4>0. 摘要</h4>


<p>2000年一开始写TinyOS时候, 它的用户只是少数计算机科学的学术研究者, 10年后, TinyOS每年有25000的下载量, 被很多的商业产品所使用, 而且俨然已经变成了一个低功耗无线传感器网络的研究平台.</p>


<p>我们的关注点在于如何让技术和社会决定影响着这种成功, 有时候确实很令人惊讶.(作者很可能是在说集市的开发模式, 将TinyOS带入了一个快速的开发轨道, 也决定了这种成功的演变), 随着TinyOS的成熟, 它发展出来的语言级的扩展也在帮助用户构建更高效的、更稳定的系统.这些特性和编程抽象很切合嵌入式系统.和其他系统相比, 利用这些特性构建日益复杂的系统将会变得容易些, 这让TinyOS成了用户主要的选择.</p>


<p>这些成功其实花费了相当长的时间.一个一开始觉得好的设计随着时间的推移将变的不可预见.今天, TinyOS是一个稳定的, 自给自足的生态系统, 但这其实也阻碍了新的用户使用. 对于用户来说, 其他的一些系统比如Arduino和Contiki更易于使用, 这些系统本身已经采用了一些更好的解决方案来面对简单的嵌入式传感器应用.(这段话我一开始觉得会不会是自己翻译错了, 后来想想Philip Leveis的这种担忧不是没有道理, 本人学习TinyOS系统已经整整一年了, 也深深的明白, 对于新手来说入门会很痛苦, 很多设计或许对圈内人士是一个很方便的特性, 但是却将入门的门槛磊的越来越高, 特别是nesC语言和TinyOS系统之间千丝万缕的联系, 让很多初学者摸不着头脑)</p>


<h4>1. 介绍</h4>


<p>传感器网络的研究也就10年左右的时间, 起源于小范围的学术机构对小型, 低能量的无线感知设备的研究, 然而今天世界范围内学术研究领域出现了大量的学术会议和期刊论文, 传感器网络已经从一个研究项目成长为商业应用系统, 今天的商业系统包括:基于Ad-Hoc无线智能电表网络, 家庭网络以及工业监控系统.从Cisco(思科)开始谈论&quot;物联网&quot;概念的时候, 这将意味着未来有数百万乃至数十亿的小型网络设备将会交织在一起采集着物理世界的环境, 这就是我们所说的:传感网</p>


<p>TinyOS是一个专门为这样的嵌入式设备开发的操作系统, 它起源于UC Berkeley 2000年做传感器网络研究, 用Perl脚本自动生成一堆#define声明的年代, 从那时起, 它经过发展开始使用nesC(C语言的一门方言)语言, 经过四次主要的版本迭代, 支持10多种传感器网络平台, 并且今天, 大约每年有25000的下载量, TinyOS是无线传感器网络研究的主要平台, 使数以百计的研究成果得以实现, 它已经使用在了大量的商业产品中, 例如:Zolertia(读者可以到官方网站上看看, http://zolertia.com, MSP430+CC2420搭的), Cisco(思科)的智能电网系统(以前用的是Arch Rock公司的系统, 貌似现在Arch Rock已经被思科收购了, 看看这里http://www.cisco.com/web/about/ac49/ac0/ac1/ac259/archrock.html), 以及people power company(据我所知, 这家公司应该不再继续研究TinyOS了, 显然研究Apple和Android更顺应时代潮流. http://www.peoplepowerco.com/mobile/)</p>


<p>这篇文章主要解释TinyOS过去这十年是如何发展的, 关于TinyOS成功有两点有趣的解释, 第一, 就像Xen(开源虚拟机)和OpenFlow(这个很有趣, 它是起源於stanford为改革现有以太网数据传输而提出的第二层通信协议http://en.wikipedia.org/wiki/Openflow, 51cto有一个专题: http://network.51cto.com/art/201105/264181.htm 读者不要被它的概念吓坏了, 其实就是用软件来做原本硬件能做的事情, 这样子的案列来有GNU Radio, 这确实是一个趋势), TinyOS也是起源於学术研究项目, 获得重大成功然后开始影响到了学术界之外.同时, 仍然由学术性的研究在管理和推动着这种转变.(我认为作者其实是在表达, 美国的教育和商业之间有趣的关系, 这种正向的反馈系统也是美国教育发达的重要原因). 第二, TinyOS和其他的操作系统不一样的是它是一个成功的、原则性强的、全新的用于新型计算设备的操作系统.</p>


<p>这篇文章将解释技术和社会化的决定是如何促进而又限制TinyOS的成长, 以及因此而产生的实践, 虽然有时候这种实践以一种不可预见的方式.举个例子:我们知道细粒度组件可以允许用户很容易通过很小的改变来定制操作系统(OS), 因此TinyOS利用这一点来适应大量特殊的应用, 但是正是由于这种细粒度, 导致了阅读如此细小的组件的障碍(作者是想说易读性很差).</p>


<p>本文将被分成四部分, 第一部份:(Section 2)将描述驱动TinyOS设计的两个基本原则: 第一个是最小资源消耗. 为了生成更小的代码和减少数据占用空间, 这就要求TinyOS应该权衡运行时的灵活性和通用性, 这就和现代的很多&quot;大型(large)&quot;软件系统的设计原则相违背.第二个是要极力的消除BUG. 这个动机主要来自于调试嵌入式设备通常面临着巨大的困难, 这就要求TinyOS的架构设计很难引入BUG, 有时候这会带来一定的开销:用户写正常的代码也变得困难.为了能够支持这些原则, TinyOS的开发人员设计了nesC语言, 它是一门新的C语言方言, 这门语言和TinyOS操作系统一起在演变, 这两者交织在一起, 缺一不可: 也就是说当我们讨论TinyOS的演变时我们指的是TinyOS和nesC语言的演变.</p>


<p><img src="/images/tinyos-decade-1.png" style="width:600px;height:200px;border:solid 3px #e3e3e3;" /></p>


<h4>图1</h4>


<p>第二部分:(Section 3-6), 我们讨论四种设计上的方案对TinyOS出人意料的影响, 前两个是内存分配和隔离(我觉得这里想说的是nesC新添加的关于interface和components的命名空间),这个和嵌入式设备有关, 后两个是组件和nesC语言的设计, 它们是为了让系统软件更通用. 我们分别作简要介绍:(Section 3) 我们讨论新的语言特性是如何让TinyOS优化RAM的分配, 同时又移除了一些运行时内存访问检查. (Section 4) 第四部分描述一个新的基于这一内存分配，静态虚拟化的软件模式是如何通过使有限状态机的每个虚拟化实例完全独立来降低软件耦合度。(这里确实有点难理解, 读完第四部分就明朗了), (Section 5) 第5部分解释为何nesC对于TinyOS的早期成功是如此重要, 但是也解释了为何nesC的演变也限制了TinyOS更广泛更长期的使用. (Section 6) 第6部分关注细粒度设计带来的优缺点以及可重用的软件组件, 然后得出一个结论它们是如此简单的适合TinyOS这个操作系统(原文用a poor fit, 作者可能想表达这种设计是没办法的办法).</p>


<p>(Section 7) 第7部分从一个社会学的角度来探讨TinyOS: 这个项目是如何成长为这样一个大的开发社区? 开源项目的生与死是他们的开发者一手造成的. 今天, 由来自世界范围内的开发者和用户组成了TinyOS开发社区. 我们将探讨这样一个社区是如何组织起来以及它是如何演变, 以及这个项目遇到的各种缺陷, 包括: 招聘员工(当然开源社区没有员工这个说法, 这里指寻找有能力的开发者), 管理代码的贡献, 以及学术界和工业界的交互. 这一节还将探讨文档对用户的作用, 以及该项目是如何降低由于日益增加的技术难度给初学者造成的阻碍.</p>


<p>(Section 8) 第8部分, 退后一步, 探讨如何将从TinyOS项目学来的经验教训应用到更通用的嵌入式软件和硬件开发中. 有一个结论是细粒度的组件对于实验来说很好, 但是对于期望重用的稳定软件来说却增加了不必要和令人苦恼的复杂度(比如说内核).还有一个结论是通过抛弃一些不必要的特性, 让它以一种更自然的方式演化来做到长期满足用户的需求(这句话很实在, 确实软件的设计者更应该考虑的是用户的需求, 而不是画蛇添足), 学术研究更希望的是开拓新的技术, 但是这样做却会疏远广泛的用户, 扼杀了软件项目的长期成功.我们将讨论如何将TinyOS项目带入更广泛的用户的对策以此来避免这些和其他方面的缺陷.</p>


<h3>2. <span class="caps">MINIMIZATION</span> <span class="caps">AND</span> <span class="caps">PREVENTION</span></h3>


<p>TinyOS的发展有两个主要的目标, 最小化资源的使用和尽量阻止BUG, 两者都是为了迎合传感器网络的需求.<br />
最小化原则要求TinyOS软件系统应该尽可能少的占用硬件的资源, 这指的是更高效的计算(最小化周期次数和唤醒时间), 更少的声明(最小化RAM), 更紧凑的代码(最小化)<span class="caps">ROM</span>, 传统的计算系统也想变的高效率, 但它们却会让效率和灵活性方面做一点交换, 而效率主要体现在内核模块, 插件和其他一些机制. 相反TinyOS更专注于产生一份可以让设备在无人环境中运行数月甚至数年的极端高效的代码.</p>


<p><img src="/images/tinyos-decade-table.png" style="width:600px;height:500px;border:solid 3px #e3e3e3;" /></p>


<h3>表1</h3>


<p>嵌入式传感器设备的两个特性决定了决定了这样的最小化原则, 其一是能量, 我们知道, 在设备内部, 不管是工作状态还是在休眠状态, 硬件资源的多少和消耗的能量成正比(确实是这样的, 搞上层应用开发的人员可能觉得睡眠了怎么还会消耗能量, 确实是这样的, 因为硬件层面上我们无法真正的休眠, 只是将时钟切换到了低功耗模式, 其实硬件还是在跑), 由于节点大部分时间都在睡眠, 因此即使是很小的睡眠损耗都是很重要的部分. 表1 对TI MSP430和ARM(Cortex-M3)的几种CPU进行了比较, 16位的MSP430微控制器被广泛的使用, 正是由于它极低(1.3-2uA)的睡眠电流, 另外一款32位ARM架构号称&#8217;极低&#8217;功耗的Cortex-M3, 相反,在睡眠模式下却需要950uA的电流.</p>


<p>因为这些设备已经被设计成极低功耗的操作, 我们不可能在短期内对它们进行大的改进, 并且由于市场以及对待性能方面的考虑和处理器不同, 微控制器的发展并不遵循Moore(摩尔)定律, 因此即使是TinyOS的第一代原型产品:8kB code、512 byte RAM和48kB code、10kB RAM也存在了7年了.</p>


<p>残酷的电源能量现实(每传输一个比特, 节点离死亡就更进了一步)导致节点几乎所有的时间都在睡觉, 在这样的情况下, 相对的, 实时操作系统例如:FreeRTOS, eCos, uC/OS2将是一个很糟糕的选择, 它们的首要任务就是充分利用有限的资源, 这会让节点早日归天, 但如果资源几乎空闲, 那么调度根本不需要那样麻烦. 而且这些RTOS还需要考虑如何非常精确稳定的控制, 这是和无线传感器网络相违背的, 事实上, 也没有多大的用处.</p>


<p>第二个需要考虑的是成本, 虽然学术研究为了方便扩展, 原型可能使用顶级的微控制器, 但是对于大量的或者商业的应用, 这些花费都是过分而又没有必要的, 使用16kB的代码和512B的RAM而不是同类MSP430中最好的, 我们就可以将成本削减到6美元, 对于10万个节点, 60万美元这样的价格还是值得让我们的软件工程师优化、榨取节点上的资源的!(虽然这个有点令软件开发人员不太高兴, 但事实就是这样, 不过技术不就是在极限环境中成长起来的吗).<br />
在TinyOS前四年的发展中, RAM是最紧缺的资源, mica和mica2节点只有128kB的ROM和4kB的RAM, 应用程序会首先遇到RAM的限制, 而不是ROM. 不像PC机我们可以有虚拟内存和交换空间, 即使是稍微有一点大的程序都会使节点运行很缓慢. 而当栈溢出时, 程序要么发生编译错误, 要么发生冲突.</p>


<p>第二个原则是阻止BUG, 这主要是从软件结构上来治理. 我们知道, 所有的软件都想阻止BUG, 但不同的是TinyOS的运行在极其难以调试的传感器网络环境. 对于这种环境下的调试, 甚至引发了大量的研究. 传感器网络是一个高度分布式的系统, 节点动态地和环境以及其它节点发生交互. 资源和能量的限制阻碍了我们借助当前广泛使用的日志和传统的调试技术.很多传感器网络甚至不支持TCP连接以及单节点访问!那么我们到底用什么办法对节点进行调试呢?<br />
很多文献给出了传感器网络的应用, 监控对象从火山、鸟巢、中央空调(<span class="caps">HVAC</span>: http://en.wikipedia.org/wiki/<span class="caps">HVAC</span>)、石油开采到工业蒸汽管道. 使用TinyOS的早期版本部署应用程序时, 在系统从实验室迁移到实际环境的过程中几乎都会发生错误.随着TinyOS的发展, 这些来自于实际用户的经历导致TinyOS的开发者更强烈地要遵循阻止BUG的原则. 目前的应用程序的部署都在使用TinyOS 2.x版本, 例如2010年一个和医院合作的还不错的项目SenSys(读者可以参考这里: http://sensys.acm.org/2010/index.html).</p>


<p>为了达到这样的目的, 演变后的nesC语言原语和TinyOS编程抽象架构将传统的动态运行时操作变为静态编译时操作, 经过这样的设计就允许在极少的RAM(作者说near-optimal <span class="caps">RAM</span>)上同时支持大量的复杂而又可靠的软件系统. 接下来将探讨TinyOS在以下四个方面是如何演变的: ROM和RAM分配、代码隔离、软件组件以及语言特性.图1展示了该项目从1999到2010年的时间轴线, 标出了这其中重大的组织上和技术上的事件.</p>


<h3>3. <span class="caps">RAM</span> <span class="caps">AND</span> <span class="caps">ROM</span> <span class="caps">ALLOCATION</span></h3>


<p>TinyOS通常需要10:1的ROM和RAM的比率, 但也有一些例外, 比如存在大量的包队列和图像感知的时候, 但总的来说, 这个比率和微控制器提供的有限资源刚好很吻合. 举个例子: TinyOS 1.x主要是为mica平台设计的, 这个平台上的Atmega128微控制器有128kB的ROM和4kB的RAM, 应用程序在mica系列上运行会首先遇到RAM的瓶颈. 相反, 使用TI(德州仪器)公司48kB ROM、10kBRAM的MSP430微控制器的Telos系列, 应用程序会首先遇到ROM的瓶颈.</p>


<p>虽然大多数的努力都集中在ROM和RAM上, 但其实最小化占用CPU的周期也是很有效的策略.nesC文档讨论了减少ROM和RAM消耗的最主要的技术:使用inline和裁剪不被运行的代码, 相反, 大多数时候我们还是从软件的结构考虑优化.(作者意思可能是在语言层面上做的努力能够压榨的空间很有限, 还是需要用户写真正的节约RAM和ROM的程序, 他可能是想说TinyOS架构的设计才是重点).通常, RAM要比ROM更让人关注, 因为mica要比telos更具一般性.(这个观点和之前讨论的工业应用很吻合).</p>


<p>一些设计上通过增加代码来减小RAM的决定对于Telos平台的应用程序也提出的问题. 举个例子: 当驱动程序需要配置芯片的ADC时, 配置选项包括采集管脚、参考电压、采集持续时间、时钟源, 当驱动程序采集完ADC时, 一般需要重新进行配置参数(比如说中断标志位可能发生改变, 通常我们可能还要再次初始化), 由于这个过程通常是很快速的, 通常就像是拨动一下&quot;寄存器&quot;某一位上的开关, 在每一次ADC采集的时候, 软件会自动的处理这种配置操作. 通常情况下我们设置这些参数的手段是分配一个结构体, 然后传给ADC, 但是即使有时候ADC只需要一个副本, 这种方法却意味着要让每一个驱动代码都要维护这样一个结构体,这就浪费了RAM空间. 实际上TinyOS实现的时候是直接在栈上用一个函数来得到这个结构体. (这里有一个很重要的概念需要说明, CPU有两中体系结构:CISC和RISC, 单片机很多都是RISC, 比如AVR和MSP430, 它们在执行指令时不同的是:CISC将数据和指令集成在一起, 而RISC是指令和数据分开存放的, 因此当我们将程序写完以后是将程序烧到了ROM中, 执行过程中对于只读的部分全部从ROM中取, 也就是不会调入RAM, RAM存放全局变量、临时变量等, 因此当我们看到单片机只有128kB ROM而只有4kB RAM时不要奇怪, 我们写的代码是不会全部调入RAM的.实际上我觉得这里作者就是传达一种理念:少使用全局变量, 使用局部变量!读者查看tos/chips/atm128/adc/Atm128AdcP.nc和HplAtm128AdcP.nc, 结构体都是临时在函数内部赋值的). 我们不是在内存中维护这样一个结构体, 而是在用到的时候重新生成, 对于每一个使用ADC的设备, 我们可以通过这种技术手段将RAM降低4byte但同时提高ROM 50-60byte. 这种方法在mica平台上运行的很好, 但是对于Telos应用来说&quot;ADC膨胀&quot;却成了很普遍的兼容性问题. 倾向与减少RAM和倾向于减少ROM的API函数看起来也相当的不同, 这就要求开发者二选一或者采用其他的一些让代码不兼容的方法.</p>


<p>通过系统的APIs来最小化RAM有时候是一个极其严峻的挑战. 虽然传统的操作系统希望快速的系统调用, 但TinyOS操作系统却希望它们能够尽可能的减少RAM的使用. 很典型的一个例子就是定时器服务(Timer Service). 系统内的很多组件都需要定时器. 应用程序需要周期性地采集数据、路由协议需要周期性的发送信标、而链路层需要管理避退和重传的间隔.一个完整的应用程序可能需要3-15个定时器, 而每一个32位的定时器都需要10bytes来存储状态(启动之后的间隔、一些控制位, 比如重复定时器), 在最好的情况下, 系统会为每一个定时器分配10bytes的空间, 不会再少了.</p>


<p>第一个版本的定时器系统(1.0之前的版本, 很可惜, 现在已经找不到了, 如果读者知道在哪里下载, 一定要告诉我.)是直接让每一个客户程序自己分配定时器的状态信息然后将这个指针传递给这个定时器系统. 这一方面意味着客户程序需要分配精确个数的定时器结构体.另一方面在每一个结构体内部还需要一个额外的状态: 一个指针. 这样就可以让定时器系统在实现的时候将他们串成一个链表.一个指针就增加了这个结构体12bytes, 又是20%的冗余.此外由于动态分配导致的内存错误已经变成了一个普遍的源代码运行时错误.由于每一个使用定时器服务的客户程序都分配自己的结构体, 例如内部的一个大小差一(off-by-one)错误将导致指针失效(这里的大小差一应该指的是C语言数组从0开始, 这样很容易导致代码发生越界, 而边界通常保存着一些重要信息比如一些指针地址, 于是系统就崩溃了), 破坏链表结构, 但或许重新调用就没有问题. 于是当你将30多个节点重新烧写完以后却出现了一个简单的内存错误, 你就再也不想这样了!</p>


<p>为了应对困难的定时器调试, 下一个版本定时器系统(v.10版本)分配了一个固定数组大小的私有定时器数据结构(也就是将链表换成了数组), 为了区分不同的定时器, nesC引入了一个特殊的函数:unique, nesC在编译的时候计算unique, 每一次对一个指定的字符串s调用unique, 都会返回一个[0,N-1]范围内独一无二的整数, N表示调用字符串s的次数, 由于在编译阶段, 我们可以载入所有的源代码, 因此nesC编译器可以解析出每一次对unique的调用, 这样就可以正确的计算出N, unique使用字符s作为管理一组独一无二的集合值的一般方法, 组件需要使用unique为定时器分配一个key, 然后将这个key传入定时器系统, 第二个版本就是用这个key来当作数组的下标来关联上面的定时器结构体数组的.</p>


<p>第二版的定时器系统更稳定了, 但是却往往浪费更多的RAM, 程序经常会将定时器结构体数组分配的足够大, 这样调用unique时候就不会出现数组越界了. 这个问题并不限定于定时器, 它广泛的存在于ADC采集, 包队列和很多其他的组件中.</p>


<p>于是第三版的定时器系统出现了!(救世主来了, v1.1版本), 它通过使用一个新的函数uniqueCount达到了最小化RAM的使用!和unique类似, uniqueCount也是接受一个指定的字符串然后返回一个整数, 但它的返回值是调用对应unique函数的总和, 比如对于定时器服务我们可以这样声明:timer_state_t timer[uniqueCount(&#8220;Timer&#8221;)];然后unique那边的key就可以据此安全的访问数组了.如果我们可以假设所有的定时器客户端程序都使用正确的字符串s, 定时器服务甚至可以省略运行时检查, 这样又可以减小代码的大小.最终, 现在的TinyOS可以为定时器服务精确分配最少的RAM, 这在mica平台上只有988byte.&quot;最小&quot;也就是说:如果每一个定时器都需要10bytes的状态信息, 那么n个定时器就应该分配n*10bytes的RAM.</p>


<h3>4. <acronym title="隔离"><span class="caps">ISOLATION</span></acronym></h3>


<p>一开始的时候, TinyOS并不支持对所有的类型进行动态内存分配. 虽然类似于malloc这样的方法确实很危险, 但确实需要使用内存分配来应对日益增长的需求.TinyOS 1.1版本对于多个组件共享一个内存资源的时候会遇到很多的问题, 例如: 系统内核的调度器提供了一个抽象叫做任务, 这是一种推迟的过程调用机制, 调度器维护了一个固定数组大小的任务数组来运行任务, 如果一个组件提交了一个任务到已满的任务数组中, 那么提交就会失败, 这就提出了一个非常困难的错误情形: 组件如何再次去提交任务呢?由于TinyOS只有一个栈空间, 因此组件是不能够自旋(原地等待再次post)或者等待的, 否则调度器就不会释放一个已经执行完的函数直到当前的函数返回(这句话可能有点绕, 其实就是说这一边一直在等待提交就是不返回, 而那边的任务却等着你返回才可以释放资源, 于是就死锁了), 而且类似于定时器这类组件必须被重新调用, 但是定时器服务也在使用任务机制, 那么就会导致定时器请求被抛弃, 这样就再也不能提交这一类任务了.</p>


<p>包传输也面临着相同的问题, 在TinyOS 1.x版本中, 如果发送队列满了那么传输请求就会出错, 因为这个队列被很多组件共享, 很有可能一个组件填满了队列就导致其他的发送组件饥饿, 而一些协议是周期性的传输数据的(比如说路由信标), 这就会导致它们被丢失, 因此TinyOS 1.x中这样一个错误的行为就可能导致整个协议栈的崩溃!</p>


<p>我们得出的结论是即使是那些隐藏起来的极其有限的全局的、共享内存池, 无论是对于要求鲁棒性的软件还是上文提到的阻止BUG这样的原则来说都是极其危险的.一个差的组件将会产生导致整个系统都难以处理的错误.它们将导致很难查到或者很难鉴别的错误, 这将会产生嵌入式平台上很难调试的令人发狂又沮丧的接口.</p>


<p>随着时间的推迟, 我们渐渐发现了其实阻碍我们在TinyOS 1.x上编写高可靠性的代码最主要的原因是:缺少隔离.通过隔离进程, 传统的操作系统可以很好的简化应用程序的实现, 相反, 任务队列的例子就显示了TinyOS 1.x隔离做的很差.这样的例子数不胜数, 例如链路层的发送队列, 采集部分, 以及每一个操作系统都不例外的定时器.因此, 要想构建非常健壮的TinyOS 1.x程序我们必须尽可能考虑并处理所有的失败和错误情形, 即使这样会增加RAM和ROM的消耗.</p>


<p>TinyOS 2.x通过组件间隔离降低了这种情况的发生的几率. 它让每一个组件和底层的共享资源的交互完全独立, 对于每一个客户程序, 都有一个完全虚拟的实例, 例如调用send接口的返回值就是完全独立的而不管其它的包是否在传输队列中. 然而对于这种形式的内存分配需要在编译的时候, 否则它将引入运行时错误.(这里应该就是指TinyOS 2.x里面的参数化接口).</p>


<p>根据(Section 3)第三部分, TinyOS 2.x为了完成这种静态虚拟化行为, 主要是借助通用组件(generic components)以及内存分配技术两者, 通用组件是可以实例化的nesC组件, 它可以接受自定义类型和普通元数据类型(在2.x版本之前, 在全局作用域范围内, 所有的nesC组件都是单一组件), 通用组件提高了代码的重用, 这个和java的generic、C++的模版以及其他语言的相似机制是异曲同工的.</p>


<p>静态虚拟化背后的基本理念是一组软件可以被声明为逻辑上的(虚拟的)服务实例, 例如发送链路层包的能力, 这类API接口的行为是完全独立于其它用户操作该API表现出行为的(这里也需要解释一下:也就是用户之间没有干扰, 也不知道之间的存在, 这就像多任务一样).调用方知道任何调用的结果, 这是因为对于所有的传输来说所有的有限状态机的接口都来自那个调用者.这个和传统上我们所说的只有一个API接口并且避免共享状态是不同的.(也就是和单任务是不同的).</p>


<p>TinyOS完成整个静态虚拟话的工作是完全在编译时进行的, 它使用抽象出来的叫做参数化接口的概念来区分多个客户程序.现在我们知道unique和uniqueCount这两个函数是用来确定客户实例号以及它们的总数的, 而通用组件(generic components)是通过对用户屏蔽机器特性来阻止BUG. 在TinyOS 2.x中不管是所有的API还是系统服务都在使用静态虚拟化技术.例如, 为了发送链路层的包, 客户程序实例化了一个AMSenderC组件, AMSenderC组件有一个特性就是拒绝同一个客户程序重复请求.</p>


<p>在底层, AMSenderC将AMSend接口连接到了一个包队列, 我们可以在图2中看出来.包队列有一个参数化的Send接口, 而每一次实例化一个AMSenderC都会调用unique, 包队列就会调用uniqueCount来分配正确的队列长度, 当组件尝试发送包的时候, 包队列就会检查所相应的条目是否已经在队列中了, 如果不在, 那么这个包就会被传输, 如果已经存在, 它就将通知调用程序重试(我已经贴出了tos/system/AMQueueImplP.nc中Send.send的实现, 使用了参数化接口高效地完成了查找).</p>


<p><img src="/images/tinyos-decade-2.png" style="width:600px;height:350px;border:solid 3px #e3e3e3;" /></p>


<h3>图二</h3>


<div class="highlight"><pre><code class="c"><span class="n">command</span> <span class="n">error_t</span> <span class="n">Send</span><span class="p">.</span><span class="n">send</span><span class="p">[</span><span class="kt">uint8_t</span> <span class="n">clientId</span><span class="p">](</span><span class="n">message_t</span><span class="o">*</span> <span class="n">msg</span><span class="p">,</span>
                                                <span class="kt">uint8_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clientId</span> <span class="o">&gt;=</span> <span class="n">numClients</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">FAIL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="n">clientId</span><span class="p">].</span><span class="n">msg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">EBUSY</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">dbg</span><span class="p">(</span><span class="s">&quot;AMQueue&quot;</span><span class="p">,</span> <span class="s">&quot;AMQueue: request to send from %hhu (%p): passed checks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clientId</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
        
        <span class="n">queue</span><span class="p">[</span><span class="n">clientId</span><span class="p">].</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
        <span class="n">call</span> <span class="n">Packet</span><span class="p">.</span><span class="n">setPayloadLength</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">&gt;=</span> <span class="n">numClients</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// queue empty</span>
            <span class="n">error_t</span> <span class="n">err</span><span class="p">;</span>
            <span class="n">am_id_t</span> <span class="n">amId</span> <span class="o">=</span> <span class="n">call</span> <span class="n">AMPacket</span><span class="p">.</span><span class="n">type</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
            <span class="n">am_addr_t</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">call</span> <span class="n">AMPacket</span><span class="p">.</span><span class="n">destination</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
      
            <span class="n">dbg</span><span class="p">(</span><span class="s">&quot;AMQueue&quot;</span><span class="p">,</span> <span class="s">&quot;%s: request to send from %hhu (%p): queue empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">clientId</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">clientId</span><span class="p">;</span>
            
            <span class="n">err</span> <span class="o">=</span> <span class="n">call</span> <span class="n">AMSend</span><span class="p">.</span><span class="n">send</span><span class="p">[</span><span class="n">amId</span><span class="p">](</span><span class="n">dest</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dbg</span><span class="p">(</span><span class="s">&quot;AMQueue&quot;</span><span class="p">,</span> <span class="s">&quot;%s: underlying send failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">);</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">numClients</span><span class="p">;</span>
                <span class="n">queue</span><span class="p">[</span><span class="n">clientId</span><span class="p">].</span><span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">dbg</span><span class="p">(</span><span class="s">&quot;AMQueue&quot;</span><span class="p">,</span> <span class="s">&quot;AMQueue: request to send from %hhu (%p): queue not empty</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clientId</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>


<p>静态虚拟化是一个来自于合并了无线传感器接口unique需求的TinyOS的新的编程例子(这里就是指能够让多个实例互不干扰的工作), 这代表着我们在高效率高可靠性的嵌入式系统上前进了一大步!通过静态虚拟化, 软件能够使用操作系统提供的服务, 安全的隔离来自其他客户程序的相同服务.由于API的行为完全基于调用的组件, 那我们就可以直接确认这些组件是正确的!(例如接口的契约), 而且底层的实现也可以精确的分配需要的RAM的大小, 以及简单, 简洁的代码.</p>


<h3>5. <span class="caps">LANGUAGE</span>/OS-<acronym title="语言和操作系统的设计"><span class="caps">DESIGN</span></acronym></h3>


<p>在早期的TinyOS开发中, 我们决定去设计一门语言来更好的支持编程和它的并发模型. nesC语言可以让TinyOS达到资源和效率的最小化(资源/效率应该越小越好, 这是最小化原则), 以及出人意料的低BUG比率(这是阻止原则). 拥有一门新的语言也能够允许我们通过进化和扩展语言特性来解决新的问题(也就是灵活性更高). 比如说静态虚拟化语言特性(参数化接口、unique、uniqueCount、generic components)合并操作4年的周期了.同时控制语言和操作系统两个层面, 给予了这个项目极大的灵活性来完成系统的设计.</p>


<p>一方面, 静态虚拟化是一个杰出的编程接口, 另一方面, 通过nesC来完成这样一个复杂的软件也证明了这种方式的强大. 达到这样的目的我们走了一条蜿蜒而又曲折的道路:4年主要版本的发布和5年系统之上的开发, 结果像静态虚拟化这样的技术却是像临时想出来的而不是计划之中的, 利用语言机制和少有的编程风格却将陌生的用户挡在了门外.(这个很是戏剧性啊, 哈哈:), 作者好像对静态虚拟化这样的技术很是情有独钟, 但是用户却不买它的账&#8230;)</p>


<p>语言的演变是一把双刃剑. 随着TinyOS变得更具鲁棒性, 用户开始利用它处理更具挑战性的项目. 操作系统和语言的共同演变满足了这样的需求. 一方面这种演变使得处理更大更困难的问题成为了可能, 另一方面, 每一个阶段的演变都会增加新的特性, 使得TinyOS和nesC与C语言之间离得越来越远, 这就阻碍了进入的壁垒, 而且越是有效的软件模式, 比如说静态虚拟化, 越是使用在复杂而又新的编程方式中, 由于过分专注了专家级的TinyOS用户以及让它更有可能写大型的软件程序, TinyOS 2.x对于新的用户来说可接触性很差, 不幸的是, 让它难以写错误的代码也导致了它很难写代码!(笔者倒是有一种欣慰, 刚开始学习TinyOS 2.x的时候挑灯夜读, 先看完了官方www.tinyos.net上的tutorials, 然后很幸运的搜索到了tinyos的英文完全版, 很艰难的看完了, 然后又很艰难的读了TEPS, 接口也看了八九不离十了, 后来发现还需要java才能和pc机通信, 又去看了java, 最后整天在tinyos底层的源代码里面跳来跳去, 还是不知所云, 写过最大的程序其实还是BlinkToRadio, 后来有到了tos/sensorboards/mts300里面随便找了几个可以读传感器的用了用, 但仅此而已, 一直感觉没有入门, 既不会移植TinyOS, 写不会写新的驱动, 而且对那些高级的特性就是头大, 还被一个学长教导过, 让我们不要学这些没用的.时至今日, 其实我觉得TinyOS给我最大的收获其实不在于系统本身, 而是它涉及到的太多了, 从硬件到软件, 从nesC到C到java, 而我又有一种探究精神, 一直想把一个问题弄明白, 知道它为什么会这样, 于是这些东西都接触到了, 虽然现在仍然停留在初级阶段, 但是对于打开思路确实非常有帮助, 其实有时候我们往往缺少的就是坚持, 总想收获很多, 这个搞一天调不通, 于是不高兴弄了, 那个配起来太烦了, 也不想做, 于是在技术面前遇到了太多选择, 在我看来每一个技术都是相通的, 特别是大师们设计的作品, 更是掺入了很多精华的设计思想, 我们在这样的一种观摩中, 既锻炼了毅力, 又学到了好的设计, 这个和初学绘画又有什么不一样吗?更重要的是TinyOS和nesC之间的有趣联系, 以及TinyOS项目本身的发展给带给我很多的启发, 从技术的权衡, 软件职责不同层面的分工, 设计模式, 甚至到软件之外社会层面上人类层面的合作与交流.做学生阶段能够产生这么大的感触我感觉值了.)</p>


<p>回顾这段历史, 专注于专家级的用户我们错失了一个很好的机会:特殊爱好者以及DIY制作群体, 通过领先的杂志媒体报道, 在过去的5年中, 我们看到了在简单、DIY电子项目巨大的增长趋势.这样的一个社区都被Arduino平台所吸引了.和TinyOS相比, Arduino相当的简陋: 只是由于简单的采集或冲动下诞生的单线程C语言程序.但是这对于爱好者来说, 它们更渴望能够很容易地看到这种结果.这就像制造一台口香糖售货机, 在你需要的时候只要敲击一下面板上神秘的按钮就可以了.(来自于&lt;&lt;制作&gt;&gt;杂志上一篇制作机器的文章), 根本不需要什么静态虚拟化, 网络数据类型以及编译时的数据竞争检测.(看的出来作者很失落, 这样一个经过优秀设计的系统却不能够为广泛的用户所知, 不能够被爱好者群体所接受, 实在是令人可惜)</p>


<p>学习nesC新的语言特性和它日益增长的API以及软件实现已经越来越困难了.事实上, 不管是演变出大量的API还是添加新的语言特性都不应该增加编程的困难度. 其实语言不需要很复杂, 最好能够让初学者很快写出简单的程序, 但程序能够解决多么复杂的问题就要看用户的认知水平了.能够举出的不仅仅是操作系统这个例子, 语言社区也有这样的问题, 比如说Perl5和Perl6, Perl5的正则表达式很像是很多UNIX里的其它小工具(sed、shells等), 因此对于一个经验丰富的UNIX用户来说学习曲线将会很平缓, 自然而然的.相反, Perl6的正则表达式引入了通过语法和规则构造的编程语言, 这就需要用户从头学起. 早期的TinyOS程序大多数是由C语言和少量的nesC组件构成的(就是说对用户还相对友好, 很好学习), 但是当前版本的代码, 几乎充噬着很多的nesC特性, 这就让学习的曲线相当的陡峭.<br />
这种陡峭的学习曲线影响着人员的配备. 学术性的项目趋向于让研究生成为它的首要开发者, 这种在研究和工程之间的矛盾有时候我们可以通过雇佣软件工程师来解决.但是对于TinyOS来说, 随着语言的演变将这个过程变得越来越复杂.不同的组织机构也尝试了好几次去雇佣TinyOS编程人员, 但是结果就很混乱了. 第一个被雇佣的人是早在TinyOS 1.0版本的时候, 而且他做了很大的贡献, 但是2005年无线传感器网络刚刚兴起的时候却离职了. 第二个被雇佣的人是在2004年TinyOS2.x刚刚开始发展的时候, Intel研究机构希望雇佣一个人做TinyOS1.x, 但是一年之后仅仅写了一个简单的组件, 于是不得不将他撤职了. 第三个被雇佣的人主要原因是做事件驱动系统, 但是那会以太网和TinyOS之间巨大的分歧, 他也做不了什么事情.现在回想一下历史, 早期雇佣的人员可以很好的学习这个系统并且和它一起演化, 这就会比后来当它具有重大改变和新的复杂度以后再去学习研究来的成功.</p>


<p><img src="/images/tinyos-decade-3.png" style="width:600px;height:600px;border:solid 3px #e3e3e3;" /></p>


<h3>图3</h3>


<p>但是有一个后来雇佣的成员对这个项目所做的贡献非常成功, 他是一个特殊而又独一无二的例子.在成为软件工程师之前, 他已经是TinyOS 2.x最大的贡献者了, 已经在研究无限传感器网络方面达到了一定的造诣, 事实上只有某一些人在为着这个社区做贡献也显示了这样一个障碍:进入操作系统/语言层面进行合作设计非常困难.<br />
其它的一些传感器网络操作系统也在慢慢填补TinyOS留下的空白. Contiki就是一个例子, 它是一个不用重新编译, 完全用C语言编写, 提供了传统的基于内核和用户程序的模型.(这里的不用重新编译应该指的是内核).虽然TinyOS比它更有效而又简洁, 但是从Contiki起步学习却更容易.今天, 一些重要的传感器研究都放到了Contiki上面而不是TinyOS.</p>


<h3><acronym title="组件"><span class="caps">COMPONENTS</span></acronym></h3>


<p>组件的概念是TinyOS编程模型的关键, 组件将接口和实现进行了分离, 提供了数据的私有性、允许代码的重用, 而且也方便了nesC语言在结构上进行很多有效的优化.综合这些因素, 在嵌入式软件中使用组件化编程相对于用C语言是一个巨大的提高.</p>


<p>虽然组件通常都很有益, 但是它们却被很差的使用. 在早期, TinyOS是被视为一个研究工具, 我们尝试通过结构化的软件来让一些小的扩展和修改来的更容易. 我们也是基于反馈(特别是早先MAC层的研究, 例如S-<span class="caps">MAC</span>), 发现很多(指研究过程中遇到的问题)其实都是由很多小的, 轻量级的组件构成的层次结构.例如, 如果有人想要修改mica平台上MAC定时器的功能(载波侦听, 避退), 这个其实就是修改一个组件, 而要是想修改数据编码/解码就改变另一个不同的组件.</p>


<p>这个想法的主要目的是方便我们进行实验.但是细粒度的组件有一个严重的缺陷我们并没有预见.今天使用最多的无线驱动(Chipon公司的CC2420)大约有2400行代码、41个不同的组件.2400行代码竟然有40多个文件!一个稍微有点小的例子是时间服务, 我们可以在图3中看出来, 包含8个组件通过利用32KHZ的比较计数器和溢出中断使之转化为毫秒粒度的定时器组件, 然后又通过3个变成了静态虚拟定时器, 最终小于1k字节的代码居然分散在11个不同的文件中.对于阻止原则和最小化原则,这的确很好.每一个这样的小组件都很容易确认和消除BUG, 而且组件间的接口也很好的保证了很好的避免了由于相同代码的不同副本出现的浪费.</p>


<p>但是从图三中我们也看出, 缺陷是细粒度组件的组合让我们在第一次接触时很难理解这个系统.大量的很小的函数片段出现在很多的文件中, 无穷无尽的间接层, 让我们追踪它的时候非常头疼.这种结构的复杂度破坏了我们的初衷, 在刚才举的CC2420例子中, 其实我们仅仅希望在41个文件中找到我们需要的那个重要的文件.当你实现了这个系统的时候, 你可能觉得这些都是有意义的, 但是对于新的用户来说, 既复杂又绕人.一个研究用户接口的人会说这个根本就不是什么问题, 只要用一个好的开发工具就可以让这些代码变的简单而又直观.然而这样的人既没有既没有找到这样的工具也没有花时间做一个出来.或许这不是什么基本问题, 而是真实而又实际的问题.</p>


<p>对于应用层的系统, 比如GUI工具包或者用鼠标单击单击的路由器, 细粒度的组件能够变得有意义, 因为每一个应用程序都是不一样的, 使用一个灵活的工具包能够很快速的提高开发的进度, 但是对于操作系统来说, 就完全不是这个样子了.到了底层对于TinyOS定时器服务来说,其实一共就只有一个利用少数几个可以列出来的微控制器构建出来的定时器系统, 并没有多少无线芯片长的和CC2420一个样子, 这里面根本就没有多少变种芯片.于是这些库将变成操作系统的基本APIs, 最终应用程序的开发者也希望稳定, 因此在这个方面的创新其实是不多的(读者也这么认为, 即使学习硬件, 其实也应该选择一款固定的平台, 并使用它来构建自己的应用, 与其说这是创新, 不如说改变, 我们其实最主要关注的不应该是搭建环境, 一旦核心的技术问题解决了, 系统自然而然就成功做出来了, 剩下的就是时间和人手了, 这就是合作的道理).</p>


<p>如果你需要适应多个独立的变化, 设计这样一种细粒度抽象是很有必要的.例如如果想要引入一个可以替换的MAC层协议(类似于那种漏斗状的MAC协议层)然后能够替换包的重传机制(比如部分数据包恢复机制, 这个机制叫做PPR, 读者可以去搜索一下, 好像还真是有模有样的.老外写了一篇论文:http://nms.csail.mit.edu/papers/fp315-jamieson.pdf), 但实际上, 操作系统的改变很少是简单修改局部或者替换一个组件这样子的. 它们不是实现很多小的组件, 而是让代码变得简单, 最终这些东西都是紧耦合在一起的.</p>


<p>我们的结论就是经过仔细设计和小心实现的操作系统要比那些使用类似于开发操作系统工具包或者设计可重用操作系统思想来的有效的多.开发更传统的操作系统的经验很好的支持了这个结论.拿到并修改linux的启动代码要比面对那些为了支持通用启动模块的组件框架来的容易的多, 我们没有看清楚的是代码重用并不是说要让整个系统能够达到这样的要求.不管是对于研究者还是工程师, 我们都希望能够设计处这样一个通用的抽象, 但是一边是完美的工艺品, 一边却仅仅是一个通用的架构你觉得哪个好?</p>


<h3>7. <span class="caps">COMMUNITY</span> <acronym title="社区结构"><span class="caps">STRUCTURE</span></acronym></h3>


<p>TinyOS一开始是UC Berkeley中一个很小的研究项目, 然而今天, 它变成了一个超大的, 全球开发者社区. 20世纪90年代早期，Linux系统在与 HURD系统的较量中取得了成功，从而证明，我们可以靠开放源码项目来建立并维持这种发挥积极作用的发展型社会，这很大程度上既是社会交流与社会结构的作用 也是社会对我们技术持续关注的结果.(关于这个项目读者不妨了解一下, 很尴尬的GNU和linux, HURD看来就是一个神话了, 不过经过minix, <span class="caps">HURD</span>, Linux我们似乎也能发现一些端倪: 是否巨内核是否全面战胜了微内核呢?这里有当年TanenBaum和Torvald之间的大辩论:英文版http://oreilly.com/catalog/opensources/book/appa.html, 翻译版:http://www.simplemind.info/technolife/projects/linus-tanenbaum.html, 一段精彩的历史!)</p>


<p>这一节主要描述的是TinyOS社区是如何进行社会性的演化的, 主要关注并考虑以下三个方面:社区的结构, 学术研究者和工业产品开发人员以及需要努力管理和支持用户.前一节我们主要TinyOS技术的演化是如何造成进入的壁垒的, 这一节主要探索后来才采用的社会化开发模式(2007年)是如何在某一些方面中和的之前所说的哪些影响的.</p>


<h4>7.1 Historial Progress(历史的进程)</h4>


<p>TinyOS社区经历了两次主要的结构上的改变, 这也可以从它的版本演变中反映出来:1999-2002的pre1.0版本, 2002-2005年的1.x版本, 2005至今的2.x版本. 接下来我们通过一个简要的回顾来对这些改变背后进行一个观察并且顺便了解一下这些主要的贡献者.</p>


<h5>7.1.1 Pre-1.0版本</h5>


<p>在1.0版本推出之前, TinyOS只是UC Berkeley大学一个很小的研究项目. 主要的作者都是一些Berkeley的学生加上一些来自UCLA和USC学校的访问学生, 后者主要贡献一些组件比如说泛洪实验.那个时候, TinyOS开发和无线传感器网络研究还没有区分开来, 研究者主要还是在UC Berkeley会见并且讨论一些主要的设计上的决定, 这种近距离的合作写出来的代码很像是大多数研究机构的代码库中的代码.</p>


<h5>7.1.2 Building a community: v1.x(构建社区)</h5>


<p>当1.0版本发布的时候, 已经通过DARPA NEST项目使得TinyOS变成了一个小型的研究型用户社区.这些用户开始贡献代码, 除了UC Berkeley的学生, TinyOS的核心开发人员开始包括一些研究者以及Intel Berkeley实验室的编程人员.Berkeley NEST项目雇佣了员工去组织展示, 他也开始贡献代码.</p>


<p>TinyOS1.x系统核心一共有37名开发者向开发树中贡献代码, 23人来自Berkeley: 16个研究生, 5个本科生, 以及两名工作人员. 还有6个来自Intel Research Berkeley研究机构, 3个来自柏林理工大学, 2个来自Crossbow公司: 一个生产Berkeley硬件设计的公司, 最后三个研究生分别来自Vanderbilt,<span class="caps">UCLA</span>,and Harvard大学.</p>


<p>尽管TinyOS1.x有很多的用户来构建这样的系统来让社区使用, 但大多数的核心TinyOS的开发还是发生在Berkeley大学, 对于主分支上的每一个TinyOS版本代码也都经过了回归测试(http://en.wikipedia.org/wiki/Regression_testing, 保证软件完整性的一种测试). 我们知道, 对于大多数的研究项目来说, 通过一个人来负责管理正式的发布版并且进行正常的回归测试, 是很有效果的.但当时并不是这样的, 研究社区只是将代码放在了不同的&quot;贡献者&quot;目录中, 于是37个TinyOS贡献者在源代码树中建立了110个目录, 遍布在超过80个项目子目录中, 从Funnelling MAC协议到压缩的闪储系统!</p>


<h5>7.1.3 Expanding globaly: v2.x(全球扩张)</h5>


<p>Berkeley和TU Berlin大学之间的紧密合作主要是寻求一个核心的TinyOS开发社区让这个项目扩张到UC Berkeley之外, 这一步转变是一个好的预兆:因为此时三个TinyOS项目最大的贡献者已经在2005年的春天离开了Berkeley, 两个已经开始在第一家公司开始了在Moteiv公司的全职工作, 当一个人拥有了展现才能的职位, 动机就来了, 拥有一个更正式的工作就会使得他们继续的为项目做贡献.</p>


<p>对于TinyOS1.x中出现的若干没有解决的结构上的缺陷, 一组TinyOS核心开发人员达成了共识, 大多数是关于稳定性的.(例如第四节描述的包传输队列), 他们在2004年10月成立了TinyOS2.x工作小组. 工作小组意识到当前最主要的挑战是TinyOS对于新的用户来说还没有一份正式的文档, 由于每一个TinyOS的抽象概念都是在回顾与重新设计中诞生的, 一些小的子项目组成立并且开始着手去定义新的接口, 并将他们整理成TinyOS增强型的提议(<span class="caps">TEPS</span>, 就是官方公布出来的那个), 一份跨Python的增强型提议(<span class="caps">PEP</span>), 还有RFC.</p>


<p>第一个完整的TinyOS2.0版本花费了两年的时间, 当开始去完成这项工作的时候, 有三家公司(Moteiv, Arch Rock以及CrossBOW)起到了很重要的作用.然而当2.0发布的时候, CrossBOW和Moteiv公司都放弃了参与, Arch Rock后来继续坚持到2007年.</p>


<p>一些小的学术机构发挥这贡献, 在Berkeley的那些开发者迁移到Arch Rock, Stanford以及Moteiv时, Berkeley的开发者一度降低到0个人, 直到后来2008-2009年初才好一点.随着时间的推移, 坚持最久最重要的学术上的贡献者是TU Berlin大学.他们不仅仅在2005-6年的时候写了很多核心的操作系统代码, 而且还继续发展它的扩展.(比如在2008-10年开发的802.15.4 MAC层协议).在2008年的时候, John Hopkins贡献了一个重编程的网络协议以及CC2420的安全的扩展.</p>


<p>在提交记录中有一个值得注意的细节, 就是都非常突然.提交往往都是都直接是一个库或者贡献, 都是很少的提交记录(比如说很少修复BUG), 很少的BUG说明了TinyOS2.x成功的遵循了那条阻止原则, 从2010年7月将代码迁移到google code上直到2011年5月, 80000行核心代码一共就只有16处BUG的记录.</p>


<h4>7.2 Industry vs. Academia(工业和学术)</h4>


<p>在开源项目的设计中, TinyOS展现了独一无二的一点, 因为我们可以看到它是研究社区大量使用的嵌入式系统. 一方面, 用户这边由于调试嵌入式代码是很困难的, 一般情况下只是使用现成的代码而不是自己重新写代码: 编写一个新的设备驱动要比写一个新的协议更令人畏惧.而另一方面研究社区也在想办法通过修改代码来提升系统的重要程度.这就存在一个冲突, 一边是让既有代码更有效率, 一边却是扩展代码来的组织研究, 这已经变成了一个让TinyOS开发社区很矛盾的地方.</p>


<p>TinyOS源代码的开发一开始是由学术推动的. 然而, 工业上的贡献的组件却一直存在着很大的争议, 例如Chipcon公司CC2420芯片链路层的协议栈, 今天使用的最主要的无线芯片, 发生了三次版本的交替, 第一次是由学术机构为TinyOS1.x而重写的协议栈, 第二次由Arch Rock公司完全重写了.第三次是由Rincon研究机构扩展了低功耗模块.虽然CC2420芯片驱动代码只有2400多行(大约占据源代码的%3), 却是使用的最为频繁, 遇到最多的, 也是最重要的部分.</p>


<p>一开始离开Berkeley而去Moteiv和Arch Rock公司的开发者继续为TinyOS2.x贡献着代码, 因为他们的公司也在支持这样一个开源的平台. 然而由于学术研究和工业上的使用两条完全不同的时间轴线, 矛盾变得越来越难以调和. Moteiv和Arch Rock公司都想尽快打造这样一个足够好的平台, 这样他们就有时间关注更高层的服务, 就可以卖钱了!学术研究却刚好相反, 正如我们在TinyOS2.x版本中看到的, 他们认为设计一个未来会很少维护的系统才是最重要的.于是底层版本在设计中出现了无数次的迭代, 比如说电源管理部分、锁部分.这就导致Moteiv和Arch Rock公司将TinyOS复制出了真正的代码库, 然后使用他们自己私有的代码库.</p>


<p>这种复制引入了很严重的冲突, 例如Moteiv公司自己发布了一个Boomerang版本, 这是一个介于TinyOS1.x到TinyOS2.x之间的支持Moteiv硬件平台的混杂版本, 同时Moteiv公司仍然参与到TinyOS2.x设计的讨论中. 一方面他们反对将TinyOS2.x引入一个离客户需求越来越远的方向, 另一方面, Moteiv公司已经开始停止贡献代码了,这使得很多人听从了这些建议开始使用Boomerang, 这让TinyOS2.x的开发进度慢了很多.</p>


<h4>7.3 Managing and Supporting Users</h4>


<p>现在, TinyOS平均每天大约有50-100或者说平均每年18000-36000的下载量, 这个数字还不包括一些开发者通过CVS, <span class="caps">SVN</span>, Git漏掉的, 完全是RPMs, Debian包, 以及VMWare镜像方面的数据, 我们也想观察来自于TinyOS发布服务器上下载日志的三种数据, 删除那些来自于机器的搜索记录, 过滤掉重复的IP(估计这里指的是CVS, <span class="caps">SVN</span>, Git), 遗憾的是由于服务器日至每两个月的轮转(应该指的是日至两个月就销毁了), 以及2010年服务器发生的更替, 都没能够让我们来统计这些数据.</p>


<p>管理这样一个如此巨大的用户是很困难的, 特别是在每一名开发者也是志愿者的时候, 学计算机出生的那些研究生很难有足够的动机而成为活跃的用户, 即使这样子也很难办的, 因为事实上TinyOS用在了很多大学的课堂上, 这些学生代表的是拥有很丰富的技术经验和能力的群体, 这些开发者根本就对那些普通人很感兴趣的问题或BUG不感冒, 但是有些问题就是很基础很基础的, 比如Java的CLASSPATH问题, 一般的C语言编程问题:&#8220;TinyOS里面有数组吗&#8221;, 或者&quot;从哪里下载TinyOS&quot;, 但这些问题一丢就是10年, 很少有人问津.</p>


<p><img src="/images/tinyos-decade-4.png" style="width:600px;height:260px;border:solid 3px #e3e3e3;" /></p>


<h3>图4</h3>


<p>TinyOS-help是主要的TinyOS帮助邮件列表, 开始于2002年5月, 我们可以从图4看出从那时起到现在发出的邮件数量. 从图中我们能看到有两个有趣的趋势: 第一个是每年刚开始的时候都会有一个下降, 因为是在冬天!第二个是邮件列表中邮件的高峰出现在2007年7月, 一共有947封邮件每个月, 从那时起, 就开始表现出稳定下降的趋势, 然而这个趋势却和下载量不匹配!</p>


<p>难道2007年出现了比邮件列表更方便的工具吗?原来, 在2007年7月份, 文档工作组开始将TinyOS迁移到一组静态的wiki页面上, 可以方便每个人对它进行修改和创建.从那时起, 随着时间的推移, TinyOS的文档数量开始得到稳定的提升, 有趣的是TinyOS-help邮件数量开始下降, 再也没有那些清一色的问题出现了.以前提出一些基础性问题的人不想再通过邮件POST那样烦了, 于是就去搜索文档或者web, 因此在邮件列表中出现了更多的技术性问题.于是开发者们也开始忽略前者, 转而开始回复那些邮件了.重复性的问题就可以直接通过Google站点搜索功能找到了.<br />
然而写教程, API文档, 以及编程手册这些事情其实是很枯燥的, 但是这些资料却需要有一个大量用户的社区去长期支持.</p>


<h3>8. <span class="caps">LESSONS</span> <acronym title="我们学到了什么"><span class="caps">LEARNED</span></acronym></h3>


<p>在过去10年间, TinyOS已经由早期Berkeley的研究生通过C语言预处理宏去维护发展到了今天80000多行代码, 由世界范围内的学术和工业开发者组成的社区使用C语言的一门方言nesC写成!在这个过程中我们既走了几步好棋也犯了一些错误.这一节我们来回答一个问题: 要是我们有后见之明, 我们还会做哪些相似的事情, 我们还去做哪些不一样的事情呢?更通俗一点, 我们怎样让一个学术性的项目更好地发展并走出学术之外呢?我们主要从TinyOS作出的5个具体的决定出发: 采用nesC语言、专注于软件组件化、依赖学术社区作为它的主要用户、和工业进行合作以及它如何去开发文档.如果有可能的话, 我们还会介绍一些其它的学术软件项目.</p>


<h4>8.1 Good: Language Extensions(好的一面, 使用了扩展的语言)</h4>


<p>不管怎么说, 采用nesC来进行开发都是正确的选择: nesC语言的特性可以让开发者使用很少的硬件资源编写更健壮的代码.如果我们停留在C语言层面, 根本就不可能出现基于TinyOS的传感器网络的今天的成就, 这个机会就可能丢给其他的那些意识到C的局限性并且采用其它替代语言开发的项目, 而且正是nesC赋予了我们灵活性, 让我们发现了使用C语言根本就不可能发现的提高系统开发能力的新的编程抽象. 比如说静态虚拟化技术.</p>


<h4>8.2 Bad: How Language Extensions Envolved(坏的一面, 扩展语言的演变)</h4>


<p>虽然采用nesC语言这个决定很好, 但是TinyOS最终如何使用它就不好说了, 一方面我们知道, &#8217;吃自己的狗粮&#8217;是很重要的法则: (这句话的言外之意就是从平台开始，然后用平台干所有事, 话说这也让我在思考JavaScript, 这也是为什么在软件行业我们不喜欢换平台, 我们情愿用自己不怎么称心的工具, 但就是不用别人那里的陌生的工具, 但其实是教我们不要不切实际, 先去做, 这个很重要, 而不是整天想什么框架, 到头来什么也没有拿出来, 换个思路想, 其实很多时候, 是一通百通的, 但前提是你得不断的去熟悉, 去钻研, 一旦达到了一定的高度, 会悟出许多看似简单, 却受用终身的真谛!这个时候不管怎么平台, 工具, 其实都是解决问题的手段, 甚至人的肉体其实只是精神和物质交流的一个媒介.再也没有对自身的关注, 没有仇恨, 只有爱&#8230;&#8230;)这也是为什么TinyOS的开发者构建了系统和之上的应用, 但是也赋予了系统优势和弱点(吃太多自己的狗粮了). 另一方面, 这也让我们混淆了到底什么叫做困难, 什么又叫做重要.站在学术研究的立场上, 追逐困难的, 未解决的问题或许是有意义的, 但是实际上采用技术手段让有些困难的问题更容易地去解决的同时, 也让简单的问题变得难以解决了, 而这确实在TinyOS中发生了.</p>


<p>回顾历史, 其实我们更好的做法是让系统的设计和演变分成两半, 前者用来更容易的去构建更大更复杂的系统, 后者用来构建一个更容易进行实验的系统, 但或许激发那些研究系统和网络的研究生采用第二套方案更容易失败,但是, 我们可以想想TinyOS的开发如果让Stanford和Carnegie Mellon大学也参与而飞速地开发传感器设备的原型, 可能就会出现使用低功耗无线传感器设备开发全新的应用的例子. Arduinos, 虽然也部分填补了这一方面, 但是在网络方面却有着有限的能力.谁知道要是这些由TinyOS替代的话, 那么新的科学实验、艺术作品、或者玩具会是什么一个样子??</p>


<p>另一方面, nesC的演变也让我们发现了一种新的、更好的方式去编写有效的, 无错的嵌入式代码. 要是时光可以倒流, 我们首先要做的事情就是完完全全重新设计这们语言, 或者设计一个新的来更好的支持这样一种结构的编程理念, 而不是使用那些具有通用特性的语言.比如, 我们可以采用一种方式来定义可以自动完成参数设置, unique以及状态管理所有这些事情的静态虚拟化方法, 一个文件就可以定义这个服务, 而不是像现在这样, 需要至少4个文件.</p>


<h4>8.3 Software Components(软件组件)</h4>


<p>组件和基本的C代码比起来确实是一个很重要的提高, 他们提供了这样一种即干净的、可重用的、数据私有化又可以让一些工具可以检查确认TinyOS代码的方法(作者这里说的是编译器可以根据这样一个特性做很多的优化), 组件鼓励我们通过将一个复杂的问题、复杂的系统分解为一组小的问题, 来构成简洁的系统.小到射击定位类应用程序大到Tenet这样一个编程系统.(Tenet这个貌似很强大的样子, 有空可以看看, 一个无线传感器网络方面的论文:http://enl.usc.edu/papers/cache/Gnawali06.pdf)</p>


<h4>8.4 Software Components Architectures(软件组件架构)</h4>


<p>面对这些应用, 不可避免的, 学术研究更倾向于通过给系统核心定义一个架构来使得它通用化.比如说TinyOS网络层的架构, 但实际上, 后来证明这些为了这些通用性而做的努力并不比它的价值来的大, 如果针对任意给定的抽象都用很多较小的实现来做(转发规则、链路评估), 那么通用性带来的结构上的复杂度将增加它的有害性.&#8220;不要通用, 通用通常都是错的&#8221;, 实际上, 容易移植和修改的往往是那些简单、易于理解, 没有太多乱七八糟复杂结构的代码.其实我们一开始应该使用细粒度的组件, 然后随着时间的推移以及它的稳定, 将这些组件进行整合成一个组件.</p>


<h4>8.5 Good: Initial Users</h4>


<p>没有Nest项目, TinyOS项目就可能不会这么快离开Berkeley和其它一些学校去更大的世界发展.NEST带动了Berkeley的开发者将一个普通的项目变成一个真正的软件工程项目:一旦有人开始使用这些代码, 于是也就产生了影响.这也让软件能够走出Berkeley之外, 让大家可以使用、扩展以及比较它. 最终, 就创造出了一种能够让大家将社会知识和积累应用在这个项目上的契机.当一个研究者考虑使用TinyOS的时候, 就有机会知道其他人和组织已经做过了什么, 也就能从这里学到东西.</p>


<p>很显然, 创建这样一个初始的用户群体(应该类似于TinyOS初期伯克利里面的学生用户群体)很困难的, 里面的每个人该怎么做呢?有两种方案:一种是尽力让内部的用户使用起来, 也许其他的组织和研究者就会发现居然有这样一个很好用的系统.一个显著成功的例子是Click modular router(参考http://read.cs.ucla.edu/click/, 可以自由定制路由器), Click, 起源于MIT, 现在已经被很多的也是MIT的研究项目所使用, 比如Roofnet以及无线网络编码等项目.Click的成功显示了这不仅是一个研究性项目, 而且还是一个被许多研究者和公司使用的工具.</p>


<p>通常, 第二个方案更容易成功, 那就是去找一个项目, 寄生在上面, 对于TinyOS来说, 对于NEST项目, 确实需要使用TinyOS, 当然这也存在缺点.一些NEST项目的参与者仍然极力反对项目使用TinyOS. 其它成功的例子就没有那么极端了, 比如说DHash++, 它既是IRIS项目的一部分, 也是PlanetLab和Intel项目的一部分.</p>


<h4>8.6 Bad: Focusing on Experts(坏的一面, 定位在专业用户)</h4>


<p>回顾过去, 过多的关注技术社区的成长使得TinyOS更专注了技术的复杂度. 即使大方向是技术, 我们也应该拓宽参与度. 但是过分的追求技术的影响, 导致了研究者成了项目的主导.</p>


<p>虽然我们其实也可以对技术社区之外的用户产生影响(比如说MIT的X, Berkeley的BSD, CMU的Mach, 剑桥的Xen, 以及最近出现的Stanford的OpenFlow都是很显著的例子), 但是这对于嵌入式软件来说确实极其困难的. 由于嵌入式系统往往是封闭的、单一的供应商, 当供应商较少的透露底层细节时, 系统就变得垂直整合.同样有趣的是, 虽然我们知道有很多的公司在使用TinyOS开发产品, 但是能说出来的也就那么几个.</p>


<h4>8.7 Bad: Early Industrial Involvement(工业参与过早)</h4>


<p>TinyOS2.x刚开始的时候, 就已经有好几个公司参与了它的设计进程, 但是由于它们开发时间非常紧张, 远远超过了学术研究, 导致最终都在9个月之内放弃了参与. 长时间的讨论、无数次的设计上的迭代确实很令人沮丧, 于是Moteiv和Arch Rock公司事实上都是将源代码主分支复制到他们自己的开发分支中独立进行了.同样令人沮丧的也是目的不一样:Arch Rock和Moteiv公司都希望更关注于他们自己使用的硬件平台, 但是学术研究更希望的是能够支持多种硬件设备, 更通用.</p>


<p>特别的, 很多早期的来自Crossbow和Moteiv关于TinyOS2.x可编程性方面的批评, 回顾历史, 都是完全错误的.然而当时我们却错误的相信应该让工业尽早的参与进来.TinyOS其实本可以仔细的聆听来自工业合作者的表现出来的需求, 并从中受益.但是当年的这些伙伴后来却都离开了.</p>


<h4>8.8 Good: Late Industrial Involvement(后期工业的参与)</h4>


<p>然而06年早期的时候, TinyOS2.x核心部分一设计完成, 一些公司例如Rincon Research, handhelds.org, Zolerta以及Shockfish开始参与进来, 并且对项目产生了重大的贡献. 这些贡献的代码主要是为了驱动他们自己的硬件平台, 尽管也包含较少的一些工具库. 往往商业上的工程师更愿意为设计了很好的结构、精确稳定的接口的系统编写代码, 而不是去包容那些有时看上去像充噬着关于宇宙哲学辩论的系统.斯坦福大学的OpenFlow项目就是一个后期才开始商业合作的项目, 而不是早期.这就比TinyOS采用的方法要好.关于OpenFlow以及Xen的原始设计起源于斯坦福和剑桥.但随着时间的推移, 工业的参与着也愿意实现、扩展并且使用这个系统.</p>


<h5>8.9 Good: Diverse Documentation</h5>


<p>随着用户社区的成长, 文档成了一个严重的问题, 以至于有点拖后腿.虽然编写文档很消耗时间, 但是它对于长期保存问题的答案很有价值. 最终TinyOS社区决定要编写三种形式的文档: 1. 教程, 只要是用来起步的2. <span class="caps">TEPS</span>, 这是API和实现的一个参考. 3. 以及一份TinyOS编程手册(超过200页), 主要是深入进去, 介绍一些高级编程的细节以及软件工程的技术.教程, 关注的是如何让新的用户编写程序以及使用一些简单的函数. TEPs解释系统绝大多数的功能, 这是为了让用户去实现一些新的东西.而编程手册主要是帮助用户编写大型、复杂的软件代码.</p>


<p>编写好的文档有一点令人沮丧的是我们从用户那里听到的声音少了: 没有什么新的消息.于是当TinyOS wiki站点建立以后, 一些开发者开始怀疑问题越来越少是不是因为大家都离开TinyOS社区啦?!但是下载量又说明了:使用TinyOS的人越来越多了, 但是问问题的少了.</p>


<h5>8.10 Bad: Only Developer Documentation</h5>


<p>事实上, 为各种不同技术背景的用户编写文档是一件很有挑战性的工作.当TinyOS在早期的演变过程中, 还不是很复杂的时候, 由开发者编写的文档自然能够被其他的C程序员看懂, 但是随着系统变得越来越复杂, 专家级的开发者增多, 教程也变得既冗长又难以理解.</p>


<p>回顾历史, TinyOS将文档整理到wiki上也太迟了! 这主要是我们有一点担心: 一旦我们将文档开放给用户, 那么他们会写很多错误的东西.但是其实即使有一处写错了, 往往有10处相同的地方是对的.而且一旦用户认为某一段文档是正需要的, 他也会去相信它并且去积极思考, 这样也会发现其中的问题.例如, 最早的由社区贡献的文档都被放在了另外一个链接下:http://docs.tinyos.net, 这是一个很小的展示TinyOS编程的页面.我们一开始觉得, 一些小的东西我们应该把它们放在教程里面, 或者更深层次的站点里面.但是, 从历史角度看, 我们其实应该留给用户决定.</p>


<p>但是, 一个人根本无法做到:创建一个wiki页面, 然后希望别人让它流行.于是开发者不得不努力的整理文档.其实用户就和我们每个人一样, 他们更多关注的是能从这里得到什么而不是去为这里创造什么.</p>


<h3>9. <acronym title="结论"><span class="caps">CONCLUSION</span></acronym></h3>


<p>10年是一个很漫长的过程, 特别是对这样一个学术性的项目. TinyOS最终成功从一个UC Berkeley的学术圈内转变为由世界范围内的开发者和用户组成的社区.这是好几百的开发者成千上万小时的努力工作!从历史角度看, 一些当时我们认为很好的决定, 长远来看却起到了消极的作用, 这说明我们没有很好的预见性.例如, 虽然设计语言的扩展对于更好地提高操作系统的可编程性很有意义, 但是这样的一种操作系统的演变也疏远了新的用户, 限制了长期的发展.</p>


<p>TinyOS已经成为了无线传感器网络研究和工程应用最重要的推动者, 我们也看到了许多这样一些方面的努力, 比如IETF正在开发一套标准用于低功耗无限传感器和以太网的互联.随着日益增长的计算能力遍布社会的各个角落, 这种将大学的研究过渡为实际的、现实世界的影响和利益的能力仍然是重要而又有意义的.希望我们在这里学到的经验教训能够帮助其他的人在未来做出更好的尝试!</p>


<h3>致谢</h3>


<p>TinyOS是很多开发者共同合作的结果, 需要列在这里的太多了, 它的成功值得每一个人庆祝, 我特别需要感谢Jason Hill, David Gay, Cory Sharp, Joe Polastre, Vlado Handziski, Jan Heinrich-Hauer, Kevin Klues, David Moss, Omprakash Gnawali, Jonathan Hui, John Regehr, Matt Welsh, AlecWoo, Robert Szewczyk, Kamin Whitehouse, Philip Buonadonna,Ben Greenstein, and Miklos Maroti.另外, 如果没有David Cullar的领导, Eric Brewer富有洞察力的语言设计, Shankar Sastry的应用开发知识, 我们就不可能成功的走到今天.最后但也是最重要的是, TinyOS的成功离不开使用它的用户, 他们报告BUG、提出功能要求、努力工作, 为我们在早年很好的指明了无线传感器的研究方向.</p>


<p>我还要感谢SOSP 2011以及OSDI 2012这两个编程委员会, 他们在TinyOS成长过程中提出的极棒的建议让很多其他的研究者和工程师收益.</p>


<p>尽管这项工作得到了微软研究院、因特尔研究院、DoCoMo资本、Foundation资本, 国家科学基金会#0615308(&#8220;<span class="caps">CSR</span>-<span class="caps">EHS</span>&#8221;), #0627126(&#8220;NeTS-<span class="caps">NOSS</span>&#8221;)以及#0846014（&quot;CAREER&quot;)以及 Stanford Terman研究协会的很多的奖励, 但是在这篇材料中的发现、结论或者表达的建议都只和我个人有关, 它不代表国家科学基金会的意见.</p>


<h3><acronym title="引用"><span class="caps">REFERENCE</span></acronym></h3>


<p>请直接参看<a href="http://sing.stanford.edu/pubs/tinyos-retrospective-osdi2012.pdf">tinyos-retrospective</a>尾部的引用!</p>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;

&lt;item&gt;
  &lt;title&gt;nesC generic 关键字&lt;/title&gt;
  &lt;link href="/2012/12/nesc-generic/"/&gt;
  &lt;pubDate&gt;2012-12-12T00:00:00+08:00&lt;/pubDate&gt;
  &lt;author&gt;{"name"=&gt;"Liu Peng", "email"=&gt;"cow.vangogh@gmail.com"}&lt;/author&gt;
  &lt;guid&gt;/2012/12/nesc-generic&lt;/guid&gt;
  &lt;content:encoded&gt;&lt;![CDATA[&lt;p&gt;学习TinyOS, 一开始很迷惑关键字generic关键字, 虽然知道这样就可以new出多个实例, 但是这种朦胧的感觉却持续了很久, 最近重新审视TinyOS, 得以写下这篇理解.接下来我会用几个实例来阐述怎么使用generic.&lt;/p&gt;
</code></pre>

<h3>什么是generic</h3>


<p>nesc的generic分为generic interface和generic component翻译过来就是通用接口和通用配件.通用接口和C++的template很类似, 我们不去讨论, 因为使用起来是没有歧义的.对于通用配件我们来看看具体的困惑是什么:</p>


<h3>实例1:</h3>


<p>大家可能会被源代码弄乱, 解释一下:就是在generic configuration内部使用具体的module然后new多个这样的configuration, 看看什么效果, 真的new出多个了吗?</p>


<div class="highlight"><pre><code class="c"><span class="c1">//ITest.nc</span>
<span class="n">interface</span> <span class="n">ITest</span> <span class="p">{</span>
    <span class="n">command</span> <span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">event</span> <span class="kt">void</span> <span class="nf">testDone</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><code class="c"><span class="c1">// GeneriConfC.nc</span>
<span class="n">generic</span> <span class="n">configuration</span> <span class="nf">GeneriConfC</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">provides</span> <span class="n">interface</span> <span class="n">ITest</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
    <span class="n">components</span> <span class="n">OrdinaryModuleP</span><span class="p">;</span>
    <span class="n">ITest</span> <span class="o">=</span> <span class="n">OrdinaryModuleP</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><code class="c"><span class="c1">// OrdinaryModuleP.nc</span>
<span class="n">module</span> <span class="n">OrdinaryModuleP</span> <span class="p">{</span>
    <span class="n">provides</span> <span class="n">interface</span> <span class="n">ITest</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">localVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">command</span> <span class="kt">void</span> <span class="nf">ITest</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">localVar</span><span class="o">++</span><span class="p">;</span>
        <span class="n">signal</span> <span class="n">ITest</span><span class="p">.</span><span class="n">testDone</span><span class="p">(</span><span class="n">localVar</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><code class="c"><span class="c1">// TopAppC.nc</span>
<span class="n">configuration</span> <span class="n">TopAppC</span> <span class="p">{</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
    <span class="n">components</span> <span class="n">TopC</span> <span class="n">as</span> <span class="n">App</span><span class="p">;</span>
    <span class="n">components</span> <span class="n">new</span> <span class="n">GenericConfC</span><span class="p">()</span> <span class="n">as</span> <span class="n">G1</span><span class="p">;</span>
    <span class="n">components</span> <span class="n">new</span> <span class="n">GenericConfC</span><span class="p">()</span> <span class="n">as</span> <span class="n">G2</span><span class="p">;</span>
    <span class="n">App</span><span class="p">.</span><span class="n">ITest</span> <span class="o">-&gt;</span> <span class="n">G1</span><span class="p">;</span>
    <span class="n">App</span><span class="p">.</span><span class="n">ITest2</span> <span class="o">-&gt;</span> <span class="n">G2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><code class="c"><span class="c1">// TopC.nc</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="n">module</span> <span class="n">TopC</span> <span class="p">{</span>
    <span class="n">uses</span> <span class="n">interface</span> <span class="n">ITest</span><span class="p">;</span>
    <span class="n">uses</span> <span class="n">interface</span> <span class="n">ITest</span> <span class="n">as</span> <span class="n">ITest2</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="err">@</span><span class="n">C</span><span class="p">()</span> <span class="err">@</span><span class="n">spontaneous</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">call</span> <span class="n">ITest</span><span class="p">.</span><span class="n">test</span><span class="p">();</span>
        <span class="n">call</span> <span class="n">ITest2</span><span class="p">.</span><span class="n">test</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">event</span> <span class="kt">void</span> <span class="n">ITest</span><span class="p">.</span><span class="n">testDone</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;event ITest.testDone: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">event</span> <span class="kt">void</span> <span class="n">ITest2</span><span class="p">.</span><span class="n">testDone</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;event ITest2.testDone:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<ul>
    <li>编译生成app.c :            &gt; nescc TopAppC.nc -fnesc-cfile=app.c</li>
    <li>编译生成可执行文件a.out    &gt; nescc TopAppC.nc</li>
</ul>


<div class="highlight"><pre><code class="text">运行结果:
van9ogh@VAN9OGH $ ./a.out 
event ITest2.testDone:1
event ITest.testDone: 1
event ITest2.testDone:2
event ITest.testDone: 2
</code></pre></div>


<div class="highlight"><pre><code class="text">// app.c(删去了没必要的声明, 留下真正相关的代码)
int OrdinaryModuleP$localVar = 0;

static inline void TopC$ITest$testDone(int val) { printf(&quot;event ITest.testDone: %d\n&quot;, val); }

static inline void TopC$ITest2$testDone(int val) { printf(&quot;event ITest2.testDone:%d\n&quot;, val); }

inline static void OrdinaryModuleP$ITest$testDone(int val) {
  TopC$ITest2$testDone(val);
  TopC$ITest$testDone(val);
}
static inline void OrdinaryModuleP$ITest$test(void ) {
  OrdinaryModuleP$localVar++; 
  OrdinaryModuleP$ITest$testDone(OrdinaryModuleP$localVar); 
}

inline static void TopC$ITest$test(void ) { OrdinaryModuleP$ITest$test(); }
inline static void TopC$ITest2$test(void ){ OrdinaryModuleP$ITest$test(); }

int main(void ) {
  TopC$ITest$test();
  TopC$ITest2$test();
}
</code></pre></div>


<p>我们看到好像并没有生成两份代码拷贝的意思, 而且打印出来的结果也很令人诧异, 我们注意到不同的函数调用实际上被转发到相同的OrdinaryModuleP内部, 而对于event的处理, nesC采用广播的方式, 每一次signal其实都是将所有相关的command通知一遍.我们发现这个样子的代码几乎没有什么用处, 但我们也发现了一条可以用来广播的技巧, 不过我们还是不要趟浑水.</p>


<h3>实例2:</h3>


<p>这次我们看看正确的用法:(为了便于查看还是将所有的代码贴出)</p>


<div class="highlight"><pre><code class="c"><span class="c1">// ITest.nc</span>
<span class="n">interface</span> <span class="n">ITest</span> <span class="p">{</span>
    <span class="n">command</span> <span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">event</span> <span class="kt">void</span> <span class="nf">testDone</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><code class="c"><span class="c1">// GenericModuleP.nc</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="n">generic</span> <span class="n">module</span> <span class="nf">GenericModuleP</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">provides</span> <span class="n">interface</span> <span class="n">ITest</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">localVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">command</span> <span class="kt">void</span> <span class="n">ITest</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">localVar</span><span class="o">++</span><span class="p">;</span>
        <span class="n">signal</span> <span class="n">ITest</span><span class="p">.</span><span class="n">testDone</span><span class="p">(</span><span class="n">localVar</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><code class="c"><span class="c1">// TopC.nc</span>
<span class="n">module</span> <span class="n">TopC</span> <span class="p">{</span>
    <span class="n">uses</span> <span class="n">interface</span> <span class="n">ITest</span><span class="p">;</span>
    <span class="n">uses</span> <span class="n">interface</span> <span class="n">ITest</span> <span class="n">as</span> <span class="n">ITest2</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="err">@</span><span class="n">C</span><span class="p">()</span> <span class="err">@</span><span class="n">spontaneous</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">call</span> <span class="n">ITest</span><span class="p">.</span><span class="n">test</span><span class="p">();</span>
        <span class="n">call</span> <span class="n">ITest2</span><span class="p">.</span><span class="n">test</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">event</span> <span class="kt">void</span> <span class="n">ITest</span><span class="p">.</span><span class="n">testDone</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;event ITest.testDone: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">event</span> <span class="kt">void</span> <span class="n">ITest2</span><span class="p">.</span><span class="n">testDone</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;event ITest2.testDone:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><code class="c"><span class="c1">// TopAppC.nc</span>
<span class="n">configuration</span> <span class="n">TopAppC</span> <span class="p">{</span>
<span class="p">}</span>
<span class="n">implementation</span> <span class="p">{</span>
    <span class="n">components</span> <span class="n">TopC</span> <span class="n">as</span> <span class="n">App</span><span class="p">;</span>
    <span class="n">components</span> <span class="n">new</span> <span class="n">GenericModuleP</span><span class="p">()</span> <span class="n">as</span> <span class="n">G1</span><span class="p">;</span>
    <span class="n">components</span> <span class="n">new</span> <span class="n">GenericModuleP</span><span class="p">()</span> <span class="n">as</span> <span class="n">G2</span><span class="p">;</span>
    <span class="n">App</span><span class="p">.</span><span class="n">ITest</span> <span class="o">-&gt;</span> <span class="n">G1</span><span class="p">;</span>
    <span class="n">App</span><span class="p">.</span><span class="n">ITest2</span> <span class="o">-&gt;</span> <span class="n">G2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>编译就不说了, 我们看看运行结果:</p>


<div class="highlight"><pre><code class="text">van9ogh@VAN9OGH $ ./a.out 
event ITest.testDone: 1
event ITest2.testDone:1
</code></pre></div>


<p>我们看到这次正常了.我们再看看源代码验证一下:</p>


<div class="highlight"><pre><code class="text">// app.c
int GenericModuleP$0$localVar = 0;
int GenericModuleP$1$localVar = 0;

static inline void TopC$ITest$testDone(int val) { printf(&quot;event ITest.testDone: %d\n&quot;, val); }

inline static void GenericModuleP$0$ITest$testDone(int val){
  TopC$ITest$testDone(val);
}
static inline void GenericModuleP$0$ITest$test(void )
{
  GenericModuleP$0$localVar++;
  GenericModuleP$0$ITest$testDone(GenericModuleP$0$localVar);
}

inline static void TopC$ITest$test(void) { GenericModuleP$0$ITest$test(); }
static inline void TopC$ITest2$testDone(int val) { printf(&quot;event ITest2.testDone:%d\n&quot;, val); }

inline static void GenericModuleP$1$ITest$testDone(int val) { TopC$ITest2$testDone(val); }
static inline void GenericModuleP$1$ITest$test(void )
{
  GenericModuleP$1$localVar++;
  GenericModuleP$1$ITest$testDone(GenericModuleP$1$localVar);
}

inline static void TopC$ITest2$test(void) { GenericModuleP$1$ITest$test(); }
int main(void) {
  TopC$ITest$test();
  TopC$ITest2$test();
}
</code></pre></div>


<p>我们看到代码被完完全全复制了两份.</p>


<h3>总结:</h3>


<p>不要认为new出来的就真的是一份新的, nesC语言也存在深复制和潜复制的问题, 因此我们在使用generic时要谨慎, 如果使用generic configuration要保证内部的配线也要是generic module 而不是简单的module.</p>


<p>]]>&lt;/content:encoded></p>

<pre><code>&lt;/item&gt;
</code></pre>

<p>  </channel>
</rss></p>
