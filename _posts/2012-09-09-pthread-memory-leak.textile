---
layout: post
title: "pthread: 回收线程的重要性"
---

h3. 原因

p. 笔者最经在写并发服务器， 一个采用多线程accept模型， 一个采用epoll异步事件+非阻塞IO模型， 在参考并测试sourceforge上一个小型的基于多线程accept<a href="/code/c/linux/httpd.c" type="color:red">web服务器httpd.c</a>时， 遇到了pthread_create: Cannot allocate memory错误， 我使用的是apache的ab测试. 最终发现由于使用了多线程并没有pthread_join() 或者 设置分离属性， 造成了极大的内存泄露, 另外在测试过程中我发现， 即使回收了线程的资源， 但是每个进程所能分配的线程数是有限制的， 这极大的抑制了并发量, 读者可以查看一下我修改过后的代码， 带有注释, 具体不再贴代码.

p. 本机的测试环境如下， 使用多线程accept在本机测试最大并发量在30左右, 读者可以自己测试比较下， 随着机器的性能结果有差异， 不过经过此次分析， 我想要想做到高并发走apache的老路是行不通的， 我想最佳的模型应该是： 前台采用epoll异步事件+非阻塞IO模型， 后台引入线程池（少量线程）减少CPU密集计算带来的阻塞。

{% highlight bash %}
CPU:    Intel Core2 P7450 2.13GHZ
Memory: 2G

//ab test:
van9ogh@WSN $ ab -n 10000 -c 30 http://127.0.0.1:9001/index.html

// httpd服务器显示
van9ogh@WSN $ ./a.out 
httpd running on port 9001
pthread_create: Cannot allocate memory

{% endhighlight %}

h3. pmap

p. pmap， 我们使用pmap看一下当httpd.c程序出现pthread_create: Cannot allocate memory错误时， 内存的使用情况:

{% highlight bash %}
van9ogh@WSN $ pmap -d 31547
31547:   ./a.out
Address   Kbytes Mode  Offset           Device    Mapping
00110000    1660 r-x-- 0000000000000000 008:00003 libc-2.15.so
002af000       8 r---- 000000000019f000 008:00003 libc-2.15.so
002b1000       4 rw--- 00000000001a1000 008:00003 libc-2.15.so
002b2000      12 rw--- 0000000000000000 000:00000   [ anon ]
002b5000     112 r-x-- 0000000000000000 008:00003 libgcc_s.so.1
002d1000       4 r---- 000000000001b000 008:00003 libgcc_s.so.1
002d2000       4 rw--- 000000000001c000 008:00003 libgcc_s.so.1
00a18000     128 r-x-- 0000000000000000 008:00003 ld-2.15.so
00a38000       4 r---- 000000000001f000 008:00003 ld-2.15.so
00a39000       4 rw--- 0000000000020000 008:00003 ld-2.15.so
00ce1000      92 r-x-- 0000000000000000 008:00003 libpthread-2.15.so
00cf8000       4 r---- 0000000000016000 008:00003 libpthread-2.15.so
00cf9000       4 rw--- 0000000000017000 008:00003 libpthread-2.15.so
00cfa000       8 rw--- 0000000000000000 000:00000   [ anon ]
00de4000       4 r-x-- 0000000000000000 000:00000   [ anon ]
0103a000       4 ----- 0000000000000000 000:00000   [ anon ]
0103b000    8192 rw--- 0000000000000000 000:00000   [ anon ]
0183b000       4 ----- 0000000000000000 000:00000   [ anon ]
0183c000    8192 rw--- 0000000000000000 000:00000   [ anon ]
0203c000       4 ----- 0000000000000000 000:00000   [ anon ]
0203d000    8192 rw--- 0000000000000000 000:00000   [ anon ]
0283d000       4 ----- 0000000000000000 000:00000   [ anon ]
0283e000    8192 rw--- 0000000000000000 000:00000   [ anon ]
0303e000       4 ----- 0000000000000000 000:00000   [ anon ]
0303f000    8192 rw--- 0000000000000000 000:00000   [ anon ]
0383f000       4 ----- 0000000000000000 000:00000   [ anon ]
03840000    8192 rw--- 0000000000000000 000:00000   [ anon ]
04040000       4 ----- 0000000000000000 000:00000   [ anon ]
04041000    8192 rw--- 0000000000000000 000:00000   [ anon ]
04841000       4 ----- 0000000000000000 000:00000   [ anon ]
04842000    8192 rw--- 0000000000000000 000:00000   [ anon ]
05042000       4 ----- 0000000000000000 000:00000   [ anon ]
05043000    8192 rw--- 0000000000000000 000:00000   [ anon ]
05843000       4 ----- 0000000000000000 000:00000   [ anon ]
05844000    8192 rw--- 0000000000000000 000:00000   [ anon ]
06044000       4 ----- 0000000000000000 000:00000   [ anon ]
06045000    8192 rw--- 0000000000000000 000:00000   [ anon ]
06845000       4 ----- 0000000000000000 000:00000   [ anon ]
06846000    8192 rw--- 0000000000000000 000:00000   [ anon ]
07046000       4 ----- 0000000000000000 000:00000   [ anon ]
07047000    8192 rw--- 0000000000000000 000:00000   [ anon ]
07847000       4 ----- 0000000000000000 000:00000   [ anon ]
07848000    8192 rw--- 0000000000000000 000:00000   [ anon ]
bf994000     132 rw--- 0000000000000000 000:00000   [ stack ]
...............
mapped: 3110692K    writeable/private: 3105356K    shared: 0K
{% endhighlight %}

我们看到包括swap， 3G的内存全部被消耗, 注意<a href="http://linux.die.net/man/1/pmap">man pmap</a>中解释[anon]表示堆分配， [stack]表示栈分配. 系统为每一个线程分配了8M的栈空间， 而我们其实只需要和一个客户端套接字发生少量的交互而已.


