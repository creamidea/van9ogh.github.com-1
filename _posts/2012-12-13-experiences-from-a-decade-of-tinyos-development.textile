---
layout: post
title: "Experiences from a Decade of TinyOS Development"
---

h3. 这是什么

TinyOS作者之一:philip leveis对TinyOS操作系统10年的发展和展望, 笔者有幸发现这篇文章, 十分庆幸, 只能聆听大师的教诲了!以下是这篇文章的翻译.题目就不翻译了, 不想变了味道. 有些句子加入了自己的理解, 没有严格按照原句剖析主谓宾. 另外, 括号中大多是我个人的注解, 虽然注解多了, 是很令人反感的事情.花了5天终于完成了, 第一次翻译这么长的一篇论文, 总的来说, 对文章整体把握的能力还不是很到位, 因此会让读者有一种凌乱的感觉. 总之, 这个过程让我对TinyOS有了更深刻的认识!

h3. Let's Begin!

h4. 0. 摘要

2000年一开始写TinyOS时候, 它的用户只是少数计算机科学的学术研究者, 10年后, TinyOS每年有25000的下载量, 被很多的商业产品所使用, 而且俨然已经变成了一个低功耗无线传感器网络的研究平台.

我们的关注点在于如何让技术和社会决定影响着这种成功, 有时候确实很令人惊讶.(作者很可能是在说集市的开发模式, 将TinyOS带入了一个快速的开发轨道, 也决定了这种成功的演变), 随着TinyOS的成熟, 它发展出来的语言级的扩展也在帮助用户构建更高效的、更稳定的系统.这些特性和编程抽象很切合嵌入式系统.和其他系统相比, 利用这些特性构建日益复杂的系统将会变得容易些, 这让TinyOS成了用户主要的选择.

这些成功其实花费了相当长的时间.一个一开始觉得好的设计随着时间的推移将变的不可预见.今天, TinyOS是一个稳定的, 自给自足的生态系统, 但这其实也阻碍了新的用户使用. 对于用户来说, 其他的一些系统比如Arduino和Contiki更易于使用, 这些系统本身已经采用了一些更好的解决方案来面对简单的嵌入式传感器应用.(这段话我一开始觉得会不会是自己翻译错了, 后来想想Philip Leveis的这种担忧不是没有道理, 本人学习TinyOS系统已经整整一年了, 也深深的明白, 对于新手来说入门会很痛苦, 很多设计或许对圈内人士是一个很方便的特性, 但是却将入门的门槛磊的越来越高, 特别是nesC语言和TinyOS系统之间千丝万缕的联系, 让很多初学者摸不着头脑)

h4. 1. 介绍

传感器网络的研究也就10年左右的时间, 起源于小范围的学术机构对小型, 低能量的无线感知设备的研究, 然而今天世界范围内学术研究领域出现了大量的学术会议和期刊论文, 传感器网络已经从一个研究项目成长为商业应用系统, 今天的商业系统包括:基于Ad-Hoc无线智能电表网络, 家庭网络以及工业监控系统.从Cisco(思科)开始谈论"物联网"概念的时候, 这将意味着未来有数百万乃至数十亿的小型网络设备将会交织在一起采集着物理世界的环境, 这就是我们所说的:传感网

TinyOS是一个专门为这样的嵌入式设备开发的操作系统, 它起源于UC Berkeley 2000年做传感器网络研究, 用Perl脚本自动生成一堆#define声明的年代, 从那时起, 它经过发展开始使用nesC(C语言的一门方言)语言, 经过四次主要的版本迭代, 支持10多种传感器网络平台, 并且今天, 大约每年有25000的下载量, TinyOS是无线传感器网络研究的主要平台, 使数以百计的研究成果得以实现, 它已经使用在了大量的商业产品中, 例如:Zolertia(读者可以到官方网站上看看, http://zolertia.com, MSP430+CC2420搭的), Cisco(思科)的智能电网系统(以前用的是Arch Rock公司的系统, 貌似现在Arch Rock已经被思科收购了, 看看这里http://www.cisco.com/web/about/ac49/ac0/ac1/ac259/archrock.html), 以及people power company(据我所知, 这家公司应该不再继续研究TinyOS了, 显然研究Apple和Android更顺应时代潮流. http://www.peoplepowerco.com/mobile/)

这篇文章主要解释TinyOS过去这十年是如何发展的, 关于TinyOS成功有两点有趣的解释, 第一, 就像Xen(开源虚拟机)和OpenFlow(这个很有趣, 它是起源於stanford为改革现有以太网数据传输而提出的第二层通信协议http://en.wikipedia.org/wiki/Openflow, 51cto有一个专题: http://network.51cto.com/art/201105/264181.htm 读者不要被它的概念吓坏了, 其实就是用软件来做原本硬件能做的事情, 这样子的案列来有GNU Radio, 这确实是一个趋势), TinyOS也是起源於学术研究项目, 获得重大成功然后开始影响到了学术界之外.同时, 仍然由学术性的研究在管理和推动着这种转变.(我认为作者其实是在表达, 美国的教育和商业之间有趣的关系, 这种正向的反馈系统也是美国教育发达的重要原因). 第二, TinyOS和其他的操作系统不一样的是它是一个成功的、原则性强的、全新的用于新型计算设备的操作系统.

这篇文章将解释技术和社会化的决定是如何促进而又限制TinyOS的成长, 以及因此而产生的实践, 虽然有时候这种实践以一种不可预见的方式.举个例子:我们知道细粒度组件可以允许用户很容易通过很小的改变来定制操作系统(OS), 因此TinyOS利用这一点来适应大量特殊的应用, 但是正是由于这种细粒度, 导致了阅读如此细小的组件的障碍(作者是想说易读性很差).

本文将被分成四部分, 第一部份:(Section 2)将描述驱动TinyOS设计的两个基本原则: 第一个是最小资源消耗. 为了生成更小的代码和减少数据占用空间, 这就要求TinyOS应该权衡运行时的灵活性和通用性, 这就和现代的很多"大型(large)"软件系统的设计原则相违背.第二个是要极力的消除BUG. 这个动机主要来自于调试嵌入式设备通常面临着巨大的困难, 这就要求TinyOS的架构设计很难引入BUG, 有时候这会带来一定的开销:用户写正常的代码也变得困难.为了能够支持这些原则, TinyOS的开发人员设计了nesC语言, 它是一门新的C语言方言, 这门语言和TinyOS操作系统一起在演变, 这两者交织在一起, 缺一不可: 也就是说当我们讨论TinyOS的演变时我们指的是TinyOS和nesC语言的演变.

<img src="/images/tinyos-decade-1.png" style="width:600px;height:200px;border:solid 3px #e3e3e3;" />

h4. 图1


第二部分:(Section 3-6), 我们讨论四种设计上的方案对TinyOS出人意料的影响, 前两个是内存分配和隔离(我觉得这里想说的是nesC新添加的关于interface和components的命名空间),这个和嵌入式设备有关, 后两个是组件和nesC语言的设计, 它们是为了让系统软件更通用. 我们分别作简要介绍:(Section 3) 我们讨论新的语言特性是如何让TinyOS优化RAM的分配, 同时又移除了一些运行时内存访问检查. (Section 4) 第四部分描述一个新的基于这一内存分配，静态虚拟化的软件模式是如何通过使有限状态机的每个虚拟化实例完全独立来降低软件耦合度。(这里确实有点难理解, 读完第四部分就明朗了), (Section 5) 第5部分解释为何nesC对于TinyOS的早期成功是如此重要, 但是也解释了为何nesC的演变也限制了TinyOS更广泛更长期的使用. (Section 6) 第6部分关注细粒度设计带来的优缺点以及可重用的软件组件, 然后得出一个结论它们是如此简单的适合TinyOS这个操作系统(原文用a poor fit, 作者可能想表达这种设计是没办法的办法).

(Section 7) 第7部分从一个社会学的角度来探讨TinyOS: 这个项目是如何成长为这样一个大的开发社区? 开源项目的生与死是他们的开发者一手造成的. 今天, 由来自世界范围内的开发者和用户组成了TinyOS开发社区. 我们将探讨这样一个社区是如何组织起来以及它是如何演变, 以及这个项目遇到的各种缺陷, 包括: 招聘员工(当然开源社区没有员工这个说法, 这里指寻找有能力的开发者), 管理代码的贡献, 以及学术界和工业界的交互. 这一节还将探讨文档对用户的作用, 以及该项目是如何降低由于日益增加的技术难度给初学者造成的阻碍.

(Section 8) 第8部分, 退后一步, 探讨如何将从TinyOS项目学来的经验教训应用到更通用的嵌入式软件和硬件开发中. 有一个结论是细粒度的组件对于实验来说很好, 但是对于期望重用的稳定软件来说却增加了不必要和令人苦恼的复杂度(比如说内核).还有一个结论是通过抛弃一些不必要的特性, 让它以一种更自然的方式演化来做到长期满足用户的需求(这句话很实在, 确实软件的设计者更应该考虑的是用户的需求, 而不是画蛇添足), 学术研究更希望的是开拓新的技术, 但是这样做却会疏远广泛的用户, 扼杀了软件项目的长期成功.我们将讨论如何将TinyOS项目带入更广泛的用户的对策以此来避免这些和其他方面的缺陷.

h3. 2. MINIMIZATION AND PREVENTION

TinyOS的发展有两个主要的目标, 最小化资源的使用和尽量阻止BUG, 两者都是为了迎合传感器网络的需求.
最小化原则要求TinyOS软件系统应该尽可能少的占用硬件的资源, 这指的是更高效的计算(最小化周期次数和唤醒时间), 更少的声明(最小化RAM), 更紧凑的代码(最小化)ROM, 传统的计算系统也想变的高效率, 但它们却会让效率和灵活性方面做一点交换, 而效率主要体现在内核模块, 插件和其他一些机制. 相反TinyOS更专注于产生一份可以让设备在无人环境中运行数月甚至数年的极端高效的代码.

<img src="/images/tinyos-decade-table.png" style="width:600px;height:500px;border:solid 3px #e3e3e3;" />

h3. 表1


嵌入式传感器设备的两个特性决定了决定了这样的最小化原则, 其一是能量, 我们知道, 在设备内部, 不管是工作状态还是在休眠状态, 硬件资源的多少和消耗的能量成正比(确实是这样的, 搞上层应用开发的人员可能觉得睡眠了怎么还会消耗能量, 确实是这样的, 因为硬件层面上我们无法真正的休眠, 只是将时钟切换到了低功耗模式, 其实硬件还是在跑), 由于节点大部分时间都在睡眠, 因此即使是很小的睡眠损耗都是很重要的部分. 表1 对TI MSP430和ARM(Cortex-M3)的几种CPU进行了比较, 16位的MSP430微控制器被广泛的使用, 正是由于它极低(1.3-2uA)的睡眠电流, 另外一款32位ARM架构号称'极低'功耗的Cortex-M3, 相反,在睡眠模式下却需要950uA的电流.

因为这些设备已经被设计成极低功耗的操作, 我们不可能在短期内对它们进行大的改进, 并且由于市场以及对待性能方面的考虑和处理器不同, 微控制器的发展并不遵循Moore(摩尔)定律, 因此即使是TinyOS的第一代原型产品:8kB code、512 byte RAM和48kB code、10kB RAM也存在了7年了.

残酷的电源能量现实(每传输一个比特, 节点离死亡就更进了一步)导致节点几乎所有的时间都在睡觉, 在这样的情况下, 相对的, 实时操作系统例如:FreeRTOS, eCos, uC/OS2将是一个很糟糕的选择, 它们的首要任务就是充分利用有限的资源, 这会让节点早日归天, 但如果资源几乎空闲, 那么调度根本不需要那样麻烦. 而且这些RTOS还需要考虑如何非常精确稳定的控制, 这是和无线传感器网络相违背的, 事实上, 也没有多大的用处.

第二个需要考虑的是成本, 虽然学术研究为了方便扩展, 原型可能使用顶级的微控制器, 但是对于大量的或者商业的应用, 这些花费都是过分而又没有必要的, 使用16kB的代码和512B的RAM而不是同类MSP430中最好的, 我们就可以将成本削减到6美元, 对于10万个节点, 60万美元这样的价格还是值得让我们的软件工程师优化、榨取节点上的资源的!(虽然这个有点令软件开发人员不太高兴, 但事实就是这样, 不过技术不就是在极限环境中成长起来的吗).
在TinyOS前四年的发展中, RAM是最紧缺的资源, mica和mica2节点只有128kB的ROM和4kB的RAM, 应用程序会首先遇到RAM的限制, 而不是ROM. 不像PC机我们可以有虚拟内存和交换空间, 即使是稍微有一点大的程序都会使节点运行很缓慢. 而当栈溢出时, 程序要么发生编译错误, 要么发生冲突.

第二个原则是阻止BUG, 这主要是从软件结构上来治理. 我们知道, 所有的软件都想阻止BUG, 但不同的是TinyOS的运行在极其难以调试的传感器网络环境. 对于这种环境下的调试, 甚至引发了大量的研究. 传感器网络是一个高度分布式的系统, 节点动态地和环境以及其它节点发生交互. 资源和能量的限制阻碍了我们借助当前广泛使用的日志和传统的调试技术.很多传感器网络甚至不支持TCP连接以及单节点访问!那么我们到底用什么办法对节点进行调试呢?
很多文献给出了传感器网络的应用, 监控对象从火山、鸟巢、中央空调(HVAC: http://en.wikipedia.org/wiki/HVAC)、石油开采到工业蒸汽管道. 使用TinyOS的早期版本部署应用程序时, 在系统从实验室迁移到实际环境的过程中几乎都会发生错误.随着TinyOS的发展, 这些来自于实际用户的经历导致TinyOS的开发者更强烈地要遵循阻止BUG的原则. 目前的应用程序的部署都在使用TinyOS 2.x版本, 例如2010年一个和医院合作的还不错的项目SenSys(读者可以参考这里: http://sensys.acm.org/2010/index.html).

为了达到这样的目的, 演变后的nesC语言原语和TinyOS编程抽象架构将传统的动态运行时操作变为静态编译时操作, 经过这样的设计就允许在极少的RAM(作者说near-optimal RAM)上同时支持大量的复杂而又可靠的软件系统. 接下来将探讨TinyOS在以下四个方面是如何演变的: ROM和RAM分配、代码隔离、软件组件以及语言特性.图1展示了该项目从1999到2010年的时间轴线, 标出了这其中重大的组织上和技术上的事件.


h3. 3. RAM AND ROM ALLOCATION

TinyOS通常需要10:1的ROM和RAM的比率, 但也有一些例外, 比如存在大量的包队列和图像感知的时候, 但总的来说, 这个比率和微控制器提供的有限资源刚好很吻合. 举个例子: TinyOS 1.x主要是为mica平台设计的, 这个平台上的Atmega128微控制器有128kB的ROM和4kB的RAM, 应用程序在mica系列上运行会首先遇到RAM的瓶颈. 相反, 使用TI(德州仪器)公司48kB ROM、10kBRAM的MSP430微控制器的Telos系列, 应用程序会首先遇到ROM的瓶颈.

虽然大多数的努力都集中在ROM和RAM上, 但其实最小化占用CPU的周期也是很有效的策略.nesC文档讨论了减少ROM和RAM消耗的最主要的技术:使用inline和裁剪不被运行的代码, 相反, 大多数时候我们还是从软件的结构考虑优化.(作者意思可能是在语言层面上做的努力能够压榨的空间很有限, 还是需要用户写真正的节约RAM和ROM的程序, 他可能是想说TinyOS架构的设计才是重点).通常, RAM要比ROM更让人关注, 因为mica要比telos更具一般性.(这个观点和之前讨论的工业应用很吻合).

一些设计上通过增加代码来减小RAM的决定对于Telos平台的应用程序也提出的问题. 举个例子: 当驱动程序需要配置芯片的ADC时, 配置选项包括采集管脚、参考电压、采集持续时间、时钟源, 当驱动程序采集完ADC时, 一般需要重新进行配置参数(比如说中断标志位可能发生改变, 通常我们可能还要再次初始化), 由于这个过程通常是很快速的, 通常就像是拨动一下"寄存器"某一位上的开关, 在每一次ADC采集的时候, 软件会自动的处理这种配置操作. 通常情况下我们设置这些参数的手段是分配一个结构体, 然后传给ADC, 但是即使有时候ADC只需要一个副本, 这种方法却意味着要让每一个驱动代码都要维护这样一个结构体,这就浪费了RAM空间. 实际上TinyOS实现的时候是直接在栈上用一个函数来得到这个结构体. (这里有一个很重要的概念需要说明, CPU有两中体系结构:CISC和RISC, 单片机很多都是RISC, 比如AVR和MSP430, 它们在执行指令时不同的是:CISC将数据和指令集成在一起, 而RISC是指令和数据分开存放的, 因此当我们将程序写完以后是将程序烧到了ROM中, 执行过程中对于只读的部分全部从ROM中取, 也就是不会调入RAM, RAM存放全局变量、临时变量等, 因此当我们看到单片机只有128kB ROM而只有4kB RAM时不要奇怪, 我们写的代码是不会全部调入RAM的.实际上我觉得这里作者就是传达一种理念:少使用全局变量, 使用局部变量!读者查看tos/chips/atm128/adc/Atm128AdcP.nc和HplAtm128AdcP.nc, 结构体都是临时在函数内部赋值的). 我们不是在内存中维护这样一个结构体, 而是在用到的时候重新生成, 对于每一个使用ADC的设备, 我们可以通过这种技术手段将RAM降低4byte但同时提高ROM 50-60byte. 这种方法在mica平台上运行的很好, 但是对于Telos应用来说"ADC膨胀"却成了很普遍的兼容性问题. 倾向与减少RAM和倾向于减少ROM的API函数看起来也相当的不同, 这就要求开发者二选一或者采用其他的一些让代码不兼容的方法.

通过系统的APIs来最小化RAM有时候是一个极其严峻的挑战. 虽然传统的操作系统希望快速的系统调用, 但TinyOS操作系统却希望它们能够尽可能的减少RAM的使用. 很典型的一个例子就是定时器服务(Timer Service). 系统内的很多组件都需要定时器. 应用程序需要周期性地采集数据、路由协议需要周期性的发送信标、而链路层需要管理避退和重传的间隔.一个完整的应用程序可能需要3-15个定时器, 而每一个32位的定时器都需要10bytes来存储状态(启动之后的间隔、一些控制位, 比如重复定时器), 在最好的情况下, 系统会为每一个定时器分配10bytes的空间, 不会再少了.

第一个版本的定时器系统(1.0之前的版本, 很可惜, 现在已经找不到了, 如果读者知道在哪里下载, 一定要告诉我.)是直接让每一个客户程序自己分配定时器的状态信息然后将这个指针传递给这个定时器系统. 这一方面意味着客户程序需要分配精确个数的定时器结构体.另一方面在每一个结构体内部还需要一个额外的状态: 一个指针. 这样就可以让定时器系统在实现的时候将他们串成一个链表.一个指针就增加了这个结构体12bytes, 又是20%的冗余.此外由于动态分配导致的内存错误已经变成了一个普遍的源代码运行时错误.由于每一个使用定时器服务的客户程序都分配自己的结构体, 例如内部的一个大小差一(off-by-one)错误将导致指针失效(这里的大小差一应该指的是C语言数组从0开始, 这样很容易导致代码发生越界, 而边界通常保存着一些重要信息比如一些指针地址, 于是系统就崩溃了), 破坏链表结构, 但或许重新调用就没有问题. 于是当你将30多个节点重新烧写完以后却出现了一个简单的内存错误, 你就再也不想这样了!

为了应对困难的定时器调试, 下一个版本定时器系统(v.10版本)分配了一个固定数组大小的私有定时器数据结构(也就是将链表换成了数组), 为了区分不同的定时器, nesC引入了一个特殊的函数:unique, nesC在编译的时候计算unique, 每一次对一个指定的字符串s调用unique, 都会返回一个[0,N-1]范围内独一无二的整数, N表示调用字符串s的次数, 由于在编译阶段, 我们可以载入所有的源代码, 因此nesC编译器可以解析出每一次对unique的调用, 这样就可以正确的计算出N, unique使用字符s作为管理一组独一无二的集合值的一般方法, 组件需要使用unique为定时器分配一个key, 然后将这个key传入定时器系统, 第二个版本就是用这个key来当作数组的下标来关联上面的定时器结构体数组的.

第二版的定时器系统更稳定了, 但是却往往浪费更多的RAM, 程序经常会将定时器结构体数组分配的足够大, 这样调用unique时候就不会出现数组越界了. 这个问题并不限定于定时器, 它广泛的存在于ADC采集, 包队列和很多其他的组件中.

于是第三版的定时器系统出现了!(救世主来了, v1.1版本), 它通过使用一个新的函数uniqueCount达到了最小化RAM的使用!和unique类似, uniqueCount也是接受一个指定的字符串然后返回一个整数, 但它的返回值是调用对应unique函数的总和, 比如对于定时器服务我们可以这样声明:timer_state_t timer[uniqueCount("Timer")];然后unique那边的key就可以据此安全的访问数组了.如果我们可以假设所有的定时器客户端程序都使用正确的字符串s, 定时器服务甚至可以省略运行时检查, 这样又可以减小代码的大小.最终, 现在的TinyOS可以为定时器服务精确分配最少的RAM, 这在mica平台上只有988byte."最小"也就是说:如果每一个定时器都需要10bytes的状态信息, 那么n个定时器就应该分配n*10bytes的RAM.

h3. 4. ISOLATION(隔离)

一开始的时候, TinyOS并不支持对所有的类型进行动态内存分配. 虽然类似于malloc这样的方法确实很危险, 但确实需要使用内存分配来应对日益增长的需求.TinyOS 1.1版本对于多个组件共享一个内存资源的时候会遇到很多的问题, 例如: 系统内核的调度器提供了一个抽象叫做任务, 这是一种推迟的过程调用机制, 调度器维护了一个固定数组大小的任务数组来运行任务, 如果一个组件提交了一个任务到已满的任务数组中, 那么提交就会失败, 这就提出了一个非常困难的错误情形: 组件如何再次去提交任务呢?由于TinyOS只有一个栈空间, 因此组件是不能够自旋(原地等待再次post)或者等待的, 否则调度器就不会释放一个已经执行完的函数直到当前的函数返回(这句话可能有点绕, 其实就是说这一边一直在等待提交就是不返回, 而那边的任务却等着你返回才可以释放资源, 于是就死锁了), 而且类似于定时器这类组件必须被重新调用, 但是定时器服务也在使用任务机制, 那么就会导致定时器请求被抛弃, 这样就再也不能提交这一类任务了.

包传输也面临着相同的问题, 在TinyOS 1.x版本中, 如果发送队列满了那么传输请求就会出错, 因为这个队列被很多组件共享, 很有可能一个组件填满了队列就导致其他的发送组件饥饿, 而一些协议是周期性的传输数据的(比如说路由信标), 这就会导致它们被丢失, 因此TinyOS 1.x中这样一个错误的行为就可能导致整个协议栈的崩溃!

我们得出的结论是即使是那些隐藏起来的极其有限的全局的、共享内存池, 无论是对于要求鲁棒性的软件还是上文提到的阻止BUG这样的原则来说都是极其危险的.一个差的组件将会产生导致整个系统都难以处理的错误.它们将导致很难查到或者很难鉴别的错误, 这将会产生嵌入式平台上很难调试的令人发狂又沮丧的接口.

随着时间的推迟, 我们渐渐发现了其实阻碍我们在TinyOS 1.x上编写高可靠性的代码最主要的原因是:缺少隔离.通过隔离进程, 传统的操作系统可以很好的简化应用程序的实现, 相反, 任务队列的例子就显示了TinyOS 1.x隔离做的很差.这样的例子数不胜数, 例如链路层的发送队列, 采集部分, 以及每一个操作系统都不例外的定时器.因此, 要想构建非常健壮的TinyOS 1.x程序我们必须尽可能考虑并处理所有的失败和错误情形, 即使这样会增加RAM和ROM的消耗.

TinyOS 2.x通过组件间隔离降低了这种情况的发生的几率. 它让每一个组件和底层的共享资源的交互完全独立, 对于每一个客户程序, 都有一个完全虚拟的实例, 例如调用send接口的返回值就是完全独立的而不管其它的包是否在传输队列中. 然而对于这种形式的内存分配需要在编译的时候, 否则它将引入运行时错误.(这里应该就是指TinyOS 2.x里面的参数化接口).

根据(Section 3)第三部分, TinyOS 2.x为了完成这种静态虚拟化行为, 主要是借助通用组件(generic components)以及内存分配技术两者, 通用组件是可以实例化的nesC组件, 它可以接受自定义类型和普通元数据类型(在2.x版本之前, 在全局作用域范围内, 所有的nesC组件都是单一组件), 通用组件提高了代码的重用, 这个和java的generic、C++的模版以及其他语言的相似机制是异曲同工的.

静态虚拟化背后的基本理念是一组软件可以被声明为逻辑上的(虚拟的)服务实例, 例如发送链路层包的能力, 这类API接口的行为是完全独立于其它用户操作该API表现出行为的(这里也需要解释一下:也就是用户之间没有干扰, 也不知道之间的存在, 这就像多任务一样).调用方知道任何调用的结果, 这是因为对于所有的传输来说所有的有限状态机的接口都来自那个调用者.这个和传统上我们所说的只有一个API接口并且避免共享状态是不同的.(也就是和单任务是不同的).

TinyOS完成整个静态虚拟话的工作是完全在编译时进行的, 它使用抽象出来的叫做参数化接口的概念来区分多个客户程序.现在我们知道unique和uniqueCount这两个函数是用来确定客户实例号以及它们的总数的, 而通用组件(generic components)是通过对用户屏蔽机器特性来阻止BUG. 在TinyOS 2.x中不管是所有的API还是系统服务都在使用静态虚拟化技术.例如, 为了发送链路层的包, 客户程序实例化了一个AMSenderC组件, AMSenderC组件有一个特性就是拒绝同一个客户程序重复请求.

在底层, AMSenderC将AMSend接口连接到了一个包队列, 我们可以在图2中看出来.包队列有一个参数化的Send接口, 而每一次实例化一个AMSenderC都会调用unique, 包队列就会调用uniqueCount来分配正确的队列长度, 当组件尝试发送包的时候, 包队列就会检查所相应的条目是否已经在队列中了, 如果不在, 那么这个包就会被传输, 如果已经存在, 它就将通知调用程序重试(我已经贴出了tos/system/AMQueueImplP.nc中Send.send的实现, 使用了参数化接口高效地完成了查找).
	
<img src="/images/tinyos-decade-2.png" style="width:600px;height:350px;border:solid 3px #e3e3e3;" />

h3. 图二


{% highlight c %}
command error_t Send.send[uint8_t clientId](message_t* msg,
                                                uint8_t len) {
        if (clientId >= numClients) {
            return FAIL;
        }
        if (queue[clientId].msg != NULL) {
            return EBUSY;
        }
        dbg("AMQueue", "AMQueue: request to send from %hhu (%p): passed checks\n", clientId, msg);
        
        queue[clientId].msg = msg;
        call Packet.setPayloadLength(msg, len);
    
        if (current >= numClients) { // queue empty
            error_t err;
            am_id_t amId = call AMPacket.type(msg);
            am_addr_t dest = call AMPacket.destination(msg);
      
            dbg("AMQueue", "%s: request to send from %hhu (%p): queue empty\n", __FUNCTION__, clientId, msg);
            current = clientId;
            
            err = call AMSend.send[amId](dest, msg, len);
            if (err != SUCCESS) {
                dbg("AMQueue", "%s: underlying send failed.\n", __FUNCTION__);
                current = numClients;
                queue[clientId].msg = NULL;
                
            }
            return err;
        }
        else {
            dbg("AMQueue", "AMQueue: request to send from %hhu (%p): queue not empty\n", clientId, msg);
        }
        return SUCCESS;
    }
{% endhighlight %}

静态虚拟化是一个来自于合并了无线传感器接口unique需求的TinyOS的新的编程例子(这里就是指能够让多个实例互不干扰的工作), 这代表着我们在高效率高可靠性的嵌入式系统上前进了一大步!通过静态虚拟化, 软件能够使用操作系统提供的服务, 安全的隔离来自其他客户程序的相同服务.由于API的行为完全基于调用的组件, 那我们就可以直接确认这些组件是正确的!(例如接口的契约), 而且底层的实现也可以精确的分配需要的RAM的大小, 以及简单, 简洁的代码.

h3. 5. LANGUAGE/OS-DESIGN(语言和操作系统的设计)

在早期的TinyOS开发中, 我们决定去设计一门语言来更好的支持编程和它的并发模型. nesC语言可以让TinyOS达到资源和效率的最小化(资源/效率应该越小越好, 这是最小化原则), 以及出人意料的低BUG比率(这是阻止原则). 拥有一门新的语言也能够允许我们通过进化和扩展语言特性来解决新的问题(也就是灵活性更高). 比如说静态虚拟化语言特性(参数化接口、unique、uniqueCount、generic components)合并操作4年的周期了.同时控制语言和操作系统两个层面, 给予了这个项目极大的灵活性来完成系统的设计.

一方面, 静态虚拟化是一个杰出的编程接口, 另一方面, 通过nesC来完成这样一个复杂的软件也证明了这种方式的强大. 达到这样的目的我们走了一条蜿蜒而又曲折的道路:4年主要版本的发布和5年系统之上的开发, 结果像静态虚拟化这样的技术却是像临时想出来的而不是计划之中的, 利用语言机制和少有的编程风格却将陌生的用户挡在了门外.(这个很是戏剧性啊, 哈哈:), 作者好像对静态虚拟化这样的技术很是情有独钟, 但是用户却不买它的账...)

语言的演变是一把双刃剑. 随着TinyOS变得更具鲁棒性, 用户开始利用它处理更具挑战性的项目. 操作系统和语言的共同演变满足了这样的需求. 一方面这种演变使得处理更大更困难的问题成为了可能, 另一方面, 每一个阶段的演变都会增加新的特性, 使得TinyOS和nesC与C语言之间离得越来越远, 这就阻碍了进入的壁垒, 而且越是有效的软件模式, 比如说静态虚拟化, 越是使用在复杂而又新的编程方式中, 由于过分专注了专家级的TinyOS用户以及让它更有可能写大型的软件程序, TinyOS 2.x对于新的用户来说可接触性很差, 不幸的是, 让它难以写错误的代码也导致了它很难写代码!(笔者倒是有一种欣慰, 刚开始学习TinyOS 2.x的时候挑灯夜读, 先看完了官方www.tinyos.net上的tutorials, 然后很幸运的搜索到了tinyos的英文完全版, 很艰难的看完了, 然后又很艰难的读了TEPS, 接口也看了八九不离十了, 后来发现还需要java才能和pc机通信, 又去看了java, 最后整天在tinyos底层的源代码里面跳来跳去, 还是不知所云, 写过最大的程序其实还是BlinkToRadio, 后来有到了tos/sensorboards/mts300里面随便找了几个可以读传感器的用了用, 但仅此而已, 一直感觉没有入门, 既不会移植TinyOS, 写不会写新的驱动, 而且对那些高级的特性就是头大, 还被一个学长教导过, 让我们不要学这些没用的.时至今日, 其实我觉得TinyOS给我最大的收获其实不在于系统本身, 而是它涉及到的太多了, 从硬件到软件, 从nesC到C到java, 而我又有一种探究精神, 一直想把一个问题弄明白, 知道它为什么会这样, 于是这些东西都接触到了, 虽然现在仍然停留在初级阶段, 但是对于打开思路确实非常有帮助, 其实有时候我们往往缺少的就是坚持, 总想收获很多, 这个搞一天调不通, 于是不高兴弄了, 那个配起来太烦了, 也不想做, 于是在技术面前遇到了太多选择, 在我看来每一个技术都是相通的, 特别是大师们设计的作品, 更是掺入了很多精华的设计思想, 我们在这样的一种观摩中, 既锻炼了毅力, 又学到了好的设计, 这个和初学绘画又有什么不一样吗?更重要的是TinyOS和nesC之间的有趣联系, 以及TinyOS项目本身的发展给带给我很多的启发, 从技术的权衡, 软件职责不同层面的分工, 设计模式, 甚至到软件之外社会层面上人类层面的合作与交流.做学生阶段能够产生这么大的感触我感觉值了.)

回顾这段历史, 专注于专家级的用户我们错失了一个很好的机会:特殊爱好者以及DIY制作群体, 通过领先的杂志媒体报道, 在过去的5年中, 我们看到了在简单、DIY电子项目巨大的增长趋势.这样的一个社区都被Arduino平台所吸引了.和TinyOS相比, Arduino相当的简陋: 只是由于简单的采集或冲动下诞生的单线程C语言程序.但是这对于爱好者来说, 它们更渴望能够很容易地看到这种结果.这就像制造一台口香糖售货机, 在你需要的时候只要敲击一下面板上神秘的按钮就可以了.(来自于<<制作>>杂志上一篇制作机器的文章), 根本不需要什么静态虚拟化, 网络数据类型以及编译时的数据竞争检测.(看的出来作者很失落, 这样一个经过优秀设计的系统却不能够为广泛的用户所知, 不能够被爱好者群体所接受, 实在是令人可惜)

学习nesC新的语言特性和它日益增长的API以及软件实现已经越来越困难了.事实上, 不管是演变出大量的API还是添加新的语言特性都不应该增加编程的困难度. 其实语言不需要很复杂, 最好能够让初学者很快写出简单的程序, 但程序能够解决多么复杂的问题就要看用户的认知水平了.能够举出的不仅仅是操作系统这个例子, 语言社区也有这样的问题, 比如说Perl5和Perl6, Perl5的正则表达式很像是很多UNIX里的其它小工具(sed、shells等), 因此对于一个经验丰富的UNIX用户来说学习曲线将会很平缓, 自然而然的.相反, Perl6的正则表达式引入了通过语法和规则构造的编程语言, 这就需要用户从头学起. 早期的TinyOS程序大多数是由C语言和少量的nesC组件构成的(就是说对用户还相对友好, 很好学习), 但是当前版本的代码, 几乎充噬着很多的nesC特性, 这就让学习的曲线相当的陡峭.
这种陡峭的学习曲线影响着人员的配备. 学术性的项目趋向于让研究生成为它的首要开发者, 这种在研究和工程之间的矛盾有时候我们可以通过雇佣软件工程师来解决.但是对于TinyOS来说, 随着语言的演变将这个过程变得越来越复杂.不同的组织机构也尝试了好几次去雇佣TinyOS编程人员, 但是结果就很混乱了. 第一个被雇佣的人是早在TinyOS 1.0版本的时候, 而且他做了很大的贡献, 但是2005年无线传感器网络刚刚兴起的时候却离职了. 第二个被雇佣的人是在2004年TinyOS2.x刚刚开始发展的时候, Intel研究机构希望雇佣一个人做TinyOS1.x, 但是一年之后仅仅写了一个简单的组件, 于是不得不将他撤职了. 第三个被雇佣的人主要原因是做事件驱动系统, 但是那会以太网和TinyOS之间巨大的分歧, 他也做不了什么事情.现在回想一下历史, 早期雇佣的人员可以很好的学习这个系统并且和它一起演化, 这就会比后来当它具有重大改变和新的复杂度以后再去学习研究来的成功.


<img src="/images/tinyos-decade-3.png" style="width:600px;height:600px;border:solid 3px #e3e3e3;" />

h3. 图3

但是有一个后来雇佣的成员对这个项目所做的贡献非常成功, 他是一个特殊而又独一无二的例子.在成为软件工程师之前, 他已经是TinyOS 2.x最大的贡献者了, 已经在研究无限传感器网络方面达到了一定的造诣, 事实上只有某一些人在为着这个社区做贡献也显示了这样一个障碍:进入操作系统/语言层面进行合作设计非常困难.
其它的一些传感器网络操作系统也在慢慢填补TinyOS留下的空白. Contiki就是一个例子, 它是一个不用重新编译, 完全用C语言编写, 提供了传统的基于内核和用户程序的模型.(这里的不用重新编译应该指的是内核).虽然TinyOS比它更有效而又简洁, 但是从Contiki起步学习却更容易.今天, 一些重要的传感器研究都放到了Contiki上面而不是TinyOS.

h3. COMPONENTS(组件)

组件的概念是TinyOS编程模型的关键, 组件将接口和实现进行了分离, 提供了数据的私有性、允许代码的重用, 而且也方便了nesC语言在结构上进行很多有效的优化.综合这些因素, 在嵌入式软件中使用组件化编程相对于用C语言是一个巨大的提高.

虽然组件通常都很有益, 但是它们却被很差的使用. 在早期, TinyOS是被视为一个研究工具, 我们尝试通过结构化的软件来让一些小的扩展和修改来的更容易. 我们也是基于反馈(特别是早先MAC层的研究, 例如S-MAC), 发现很多(指研究过程中遇到的问题)其实都是由很多小的, 轻量级的组件构成的层次结构.例如, 如果有人想要修改mica平台上MAC定时器的功能(载波侦听, 避退), 这个其实就是修改一个组件, 而要是想修改数据编码/解码就改变另一个不同的组件.

这个想法的主要目的是方便我们进行实验.但是细粒度的组件有一个严重的缺陷我们并没有预见.今天使用最多的无线驱动(Chipon公司的CC2420)大约有2400行代码、41个不同的组件.2400行代码竟然有40多个文件!一个稍微有点小的例子是时间服务, 我们可以在图3中看出来, 包含8个组件通过利用32KHZ的比较计数器和溢出中断使之转化为毫秒粒度的定时器组件, 然后又通过3个变成了静态虚拟定时器, 最终小于1k字节的代码居然分散在11个不同的文件中.对于阻止原则和最小化原则,这的确很好.每一个这样的小组件都很容易确认和消除BUG, 而且组件间的接口也很好的保证了很好的避免了由于相同代码的不同副本出现的浪费.

但是从图三中我们也看出, 缺陷是细粒度组件的组合让我们在第一次接触时很难理解这个系统.大量的很小的函数片段出现在很多的文件中, 无穷无尽的间接层, 让我们追踪它的时候非常头疼.这种结构的复杂度破坏了我们的初衷, 在刚才举的CC2420例子中, 其实我们仅仅希望在41个文件中找到我们需要的那个重要的文件.当你实现了这个系统的时候, 你可能觉得这些都是有意义的, 但是对于新的用户来说, 既复杂又绕人.一个研究用户接口的人会说这个根本就不是什么问题, 只要用一个好的开发工具就可以让这些代码变的简单而又直观.然而这样的人既没有既没有找到这样的工具也没有花时间做一个出来.或许这不是什么基本问题, 而是真实而又实际的问题.

对于应用层的系统, 比如GUI工具包或者用鼠标单击单击的路由器, 细粒度的组件能够变得有意义, 因为每一个应用程序都是不一样的, 使用一个灵活的工具包能够很快速的提高开发的进度, 但是对于操作系统来说, 就完全不是这个样子了.到了底层对于TinyOS定时器服务来说,其实一共就只有一个利用少数几个可以列出来的微控制器构建出来的定时器系统, 并没有多少无线芯片长的和CC2420一个样子, 这里面根本就没有多少变种芯片.于是这些库将变成操作系统的基本APIs, 最终应用程序的开发者也希望稳定, 因此在这个方面的创新其实是不多的(读者也这么认为, 即使学习硬件, 其实也应该选择一款固定的平台, 并使用它来构建自己的应用, 与其说这是创新, 不如说改变, 我们其实最主要关注的不应该是搭建环境, 一旦核心的技术问题解决了, 系统自然而然就成功做出来了, 剩下的就是时间和人手了, 这就是合作的道理).

如果你需要适应多个独立的变化, 设计这样一种细粒度抽象是很有必要的.例如如果想要引入一个可以替换的MAC层协议(类似于那种漏斗状的MAC协议层)然后能够替换包的重传机制(比如部分数据包恢复机制, 这个机制叫做PPR, 读者可以去搜索一下, 好像还真是有模有样的.老外写了一篇论文:http://nms.csail.mit.edu/papers/fp315-jamieson.pdf), 但实际上, 操作系统的改变很少是简单修改局部或者替换一个组件这样子的. 它们不是实现很多小的组件, 而是让代码变得简单, 最终这些东西都是紧耦合在一起的.

我们的结论就是经过仔细设计和小心实现的操作系统要比那些使用类似于开发操作系统工具包或者设计可重用操作系统思想来的有效的多.开发更传统的操作系统的经验很好的支持了这个结论.拿到并修改linux的启动代码要比面对那些为了支持通用启动模块的组件框架来的容易的多, 我们没有看清楚的是代码重用并不是说要让整个系统能够达到这样的要求.不管是对于研究者还是工程师, 我们都希望能够设计处这样一个通用的抽象, 但是一边是完美的工艺品, 一边却仅仅是一个通用的架构你觉得哪个好?

h3. 7. COMMUNITY STRUCTURE(社区结构)

TinyOS一开始是UC Berkeley中一个很小的研究项目, 然而今天, 它变成了一个超大的, 全球开发者社区. 20世纪90年代早期，Linux系统在与 HURD系统的较量中取得了成功，从而证明，我们可以靠开放源码项目来建立并维持这种发挥积极作用的发展型社会，这很大程度上既是社会交流与社会结构的作用 也是社会对我们技术持续关注的结果.(关于这个项目读者不妨了解一下, 很尴尬的GNU和linux, HURD看来就是一个神话了, 不过经过minix, HURD, Linux我们似乎也能发现一些端倪: 是否巨内核是否全面战胜了微内核呢?这里有当年TanenBaum和Torvald之间的大辩论:英文版http://oreilly.com/catalog/opensources/book/appa.html, 翻译版:http://www.simplemind.info/technolife/projects/linus-tanenbaum.html, 一段精彩的历史!)

这一节主要描述的是TinyOS社区是如何进行社会性的演化的, 主要关注并考虑以下三个方面:社区的结构, 学术研究者和工业产品开发人员以及需要努力管理和支持用户.前一节我们主要TinyOS技术的演化是如何造成进入的壁垒的, 这一节主要探索后来才采用的社会化开发模式(2007年)是如何在某一些方面中和的之前所说的哪些影响的.

h4. 7.1 Historial Progress(历史的进程)

TinyOS社区经历了两次主要的结构上的改变, 这也可以从它的版本演变中反映出来:1999-2002的pre1.0版本, 2002-2005年的1.x版本, 2005至今的2.x版本. 接下来我们通过一个简要的回顾来对这些改变背后进行一个观察并且顺便了解一下这些主要的贡献者.

h5. 7.1.1 Pre-1.0版本

在1.0版本推出之前, TinyOS只是UC Berkeley大学一个很小的研究项目. 主要的作者都是一些Berkeley的学生加上一些来自UCLA和USC学校的访问学生, 后者主要贡献一些组件比如说泛洪实验.那个时候, TinyOS开发和无线传感器网络研究还没有区分开来, 研究者主要还是在UC Berkeley会见并且讨论一些主要的设计上的决定, 这种近距离的合作写出来的代码很像是大多数研究机构的代码库中的代码.

h5. 7.1.2 Building a community: v1.x(构建社区)

当1.0版本发布的时候, 已经通过DARPA NEST项目使得TinyOS变成了一个小型的研究型用户社区.这些用户开始贡献代码, 除了UC Berkeley的学生, TinyOS的核心开发人员开始包括一些研究者以及Intel Berkeley实验室的编程人员.Berkeley NEST项目雇佣了员工去组织展示, 他也开始贡献代码.

TinyOS1.x系统核心一共有37名开发者向开发树中贡献代码, 23人来自Berkeley: 16个研究生, 5个本科生, 以及两名工作人员. 还有6个来自Intel Research Berkeley研究机构, 3个来自柏林理工大学, 2个来自Crossbow公司: 一个生产Berkeley硬件设计的公司, 最后三个研究生分别来自Vanderbilt,UCLA,and Harvard大学.

尽管TinyOS1.x有很多的用户来构建这样的系统来让社区使用, 但大多数的核心TinyOS的开发还是发生在Berkeley大学, 对于主分支上的每一个TinyOS版本代码也都经过了回归测试(http://en.wikipedia.org/wiki/Regression_testing, 保证软件完整性的一种测试). 我们知道, 对于大多数的研究项目来说, 通过一个人来负责管理正式的发布版并且进行正常的回归测试, 是很有效果的.但当时并不是这样的, 研究社区只是将代码放在了不同的"贡献者"目录中, 于是37个TinyOS贡献者在源代码树中建立了110个目录, 遍布在超过80个项目子目录中, 从Funnelling MAC协议到压缩的闪储系统!

h5. 7.1.3 Expanding globaly: v2.x(全球扩张)

Berkeley和TU Berlin大学之间的紧密合作主要是寻求一个核心的TinyOS开发社区让这个项目扩张到UC Berkeley之外, 这一步转变是一个好的预兆:因为此时三个TinyOS项目最大的贡献者已经在2005年的春天离开了Berkeley, 两个已经开始在第一家公司开始了在Moteiv公司的全职工作, 当一个人拥有了展现才能的职位, 动机就来了, 拥有一个更正式的工作就会使得他们继续的为项目做贡献.

对于TinyOS1.x中出现的若干没有解决的结构上的缺陷, 一组TinyOS核心开发人员达成了共识, 大多数是关于稳定性的.(例如第四节描述的包传输队列), 他们在2004年10月成立了TinyOS2.x工作小组. 工作小组意识到当前最主要的挑战是TinyOS对于新的用户来说还没有一份正式的文档, 由于每一个TinyOS的抽象概念都是在回顾与重新设计中诞生的, 一些小的子项目组成立并且开始着手去定义新的接口, 并将他们整理成TinyOS增强型的提议(TEPS, 就是官方公布出来的那个), 一份跨Python的增强型提议(PEP), 还有RFC.

第一个完整的TinyOS2.0版本花费了两年的时间, 当开始去完成这项工作的时候, 有三家公司(Moteiv, Arch Rock以及CrossBOW)起到了很重要的作用.然而当2.0发布的时候, CrossBOW和Moteiv公司都放弃了参与, Arch Rock后来继续坚持到2007年.

一些小的学术机构发挥这贡献, 在Berkeley的那些开发者迁移到Arch Rock, Stanford以及Moteiv时, Berkeley的开发者一度降低到0个人, 直到后来2008-2009年初才好一点.随着时间的推移, 坚持最久最重要的学术上的贡献者是TU Berlin大学.他们不仅仅在2005-6年的时候写了很多核心的操作系统代码, 而且还继续发展它的扩展.(比如在2008-10年开发的802.15.4 MAC层协议).在2008年的时候, John Hopkins贡献了一个重编程的网络协议以及CC2420的安全的扩展.

在提交记录中有一个值得注意的细节, 就是都非常突然.提交往往都是都直接是一个库或者贡献, 都是很少的提交记录(比如说很少修复BUG), 很少的BUG说明了TinyOS2.x成功的遵循了那条阻止原则, 从2010年7月将代码迁移到google code上直到2011年5月, 80000行核心代码一共就只有16处BUG的记录.

h4. 7.2 Industry vs. Academia(工业和学术)

在开源项目的设计中, TinyOS展现了独一无二的一点, 因为我们可以看到它是研究社区大量使用的嵌入式系统. 一方面, 用户这边由于调试嵌入式代码是很困难的, 一般情况下只是使用现成的代码而不是自己重新写代码: 编写一个新的设备驱动要比写一个新的协议更令人畏惧.而另一方面研究社区也在想办法通过修改代码来提升系统的重要程度.这就存在一个冲突, 一边是让既有代码更有效率, 一边却是扩展代码来的组织研究, 这已经变成了一个让TinyOS开发社区很矛盾的地方.

TinyOS源代码的开发一开始是由学术推动的. 然而, 工业上的贡献的组件却一直存在着很大的争议, 例如Chipcon公司CC2420芯片链路层的协议栈, 今天使用的最主要的无线芯片, 发生了三次版本的交替, 第一次是由学术机构为TinyOS1.x而重写的协议栈, 第二次由Arch Rock公司完全重写了.第三次是由Rincon研究机构扩展了低功耗模块.虽然CC2420芯片驱动代码只有2400多行(大约占据源代码的%3), 却是使用的最为频繁, 遇到最多的, 也是最重要的部分.

一开始离开Berkeley而去Moteiv和Arch Rock公司的开发者继续为TinyOS2.x贡献着代码, 因为他们的公司也在支持这样一个开源的平台. 然而由于学术研究和工业上的使用两条完全不同的时间轴线, 矛盾变得越来越难以调和. Moteiv和Arch Rock公司都想尽快打造这样一个足够好的平台, 这样他们就有时间关注更高层的服务, 就可以卖钱了!学术研究却刚好相反, 正如我们在TinyOS2.x版本中看到的, 他们认为设计一个未来会很少维护的系统才是最重要的.于是底层版本在设计中出现了无数次的迭代, 比如说电源管理部分、锁部分.这就导致Moteiv和Arch Rock公司将TinyOS复制出了真正的代码库, 然后使用他们自己私有的代码库.

这种复制引入了很严重的冲突, 例如Moteiv公司自己发布了一个Boomerang版本, 这是一个介于TinyOS1.x到TinyOS2.x之间的支持Moteiv硬件平台的混杂版本, 同时Moteiv公司仍然参与到TinyOS2.x设计的讨论中. 一方面他们反对将TinyOS2.x引入一个离客户需求越来越远的方向, 另一方面, Moteiv公司已经开始停止贡献代码了,这使得很多人听从了这些建议开始使用Boomerang, 这让TinyOS2.x的开发进度慢了很多.

h4. 7.3 Managing and Supporting Users

现在, TinyOS平均每天大约有50-100或者说平均每年18000-36000的下载量, 这个数字还不包括一些开发者通过CVS, SVN, Git漏掉的, 完全是RPMs, Debian包, 以及VMWare镜像方面的数据, 我们也想观察来自于TinyOS发布服务器上下载日志的三种数据, 删除那些来自于机器的搜索记录, 过滤掉重复的IP(估计这里指的是CVS, SVN, Git), 遗憾的是由于服务器日至每两个月的轮转(应该指的是日至两个月就销毁了), 以及2010年服务器发生的更替, 都没能够让我们来统计这些数据.

管理这样一个如此巨大的用户是很困难的, 特别是在每一名开发者也是志愿者的时候, 学计算机出生的那些研究生很难有足够的动机而成为活跃的用户, 即使这样子也很难办的, 因为事实上TinyOS用在了很多大学的课堂上, 这些学生代表的是拥有很丰富的技术经验和能力的群体, 这些开发者根本就对那些普通人很感兴趣的问题或BUG不感冒, 但是有些问题就是很基础很基础的, 比如Java的CLASSPATH问题, 一般的C语言编程问题:"TinyOS里面有数组吗", 或者"从哪里下载TinyOS", 但这些问题一丢就是10年, 很少有人问津.

<img src="/images/tinyos-decade-4.png" style="width:600px;height:260px;border:solid 3px #e3e3e3;" />

h3. 图4

TinyOS-help是主要的TinyOS帮助邮件列表, 开始于2002年5月, 我们可以从图4看出从那时起到现在发出的邮件数量. 从图中我们能看到有两个有趣的趋势: 第一个是每年刚开始的时候都会有一个下降, 因为是在冬天!第二个是邮件列表中邮件的高峰出现在2007年7月, 一共有947封邮件每个月, 从那时起, 就开始表现出稳定下降的趋势, 然而这个趋势却和下载量不匹配!

难道2007年出现了比邮件列表更方便的工具吗?原来, 在2007年7月份, 文档工作组开始将TinyOS迁移到一组静态的wiki页面上, 可以方便每个人对它进行修改和创建.从那时起, 随着时间的推移, TinyOS的文档数量开始得到稳定的提升, 有趣的是TinyOS-help邮件数量开始下降, 再也没有那些清一色的问题出现了.以前提出一些基础性问题的人不想再通过邮件POST那样烦了, 于是就去搜索文档或者web, 因此在邮件列表中出现了更多的技术性问题.于是开发者们也开始忽略前者, 转而开始回复那些邮件了.重复性的问题就可以直接通过Google站点搜索功能找到了.
然而写教程, API文档, 以及编程手册这些事情其实是很枯燥的, 但是这些资料却需要有一个大量用户的社区去长期支持.

h3. 8. LESSONS LEARNED(我们学到了什么)

在过去10年间, TinyOS已经由早期Berkeley的研究生通过C语言预处理宏去维护发展到了今天80000多行代码, 由世界范围内的学术和工业开发者组成的社区使用C语言的一门方言nesC写成!在这个过程中我们既走了几步好棋也犯了一些错误.这一节我们来回答一个问题: 要是我们有后见之明, 我们还会做哪些相似的事情, 我们还去做哪些不一样的事情呢?更通俗一点, 我们怎样让一个学术性的项目更好地发展并走出学术之外呢?我们主要从TinyOS作出的5个具体的决定出发: 采用nesC语言、专注于软件组件化、依赖学术社区作为它的主要用户、和工业进行合作以及它如何去开发文档.如果有可能的话, 我们还会介绍一些其它的学术软件项目.


h4. 8.1 Good: Language Extensions(好的一面, 使用了扩展的语言)

不管怎么说, 采用nesC来进行开发都是正确的选择: nesC语言的特性可以让开发者使用很少的硬件资源编写更健壮的代码.如果我们停留在C语言层面, 根本就不可能出现基于TinyOS的传感器网络的今天的成就, 这个机会就可能丢给其他的那些意识到C的局限性并且采用其它替代语言开发的项目, 而且正是nesC赋予了我们灵活性, 让我们发现了使用C语言根本就不可能发现的提高系统开发能力的新的编程抽象. 比如说静态虚拟化技术.

h4. 8.2 Bad: How Language Extensions Envolved(坏的一面, 扩展语言的演变)

虽然采用nesC语言这个决定很好, 但是TinyOS最终如何使用它就不好说了, 一方面我们知道, '吃自己的狗粮'是很重要的法则: (这句话的言外之意就是从平台开始，然后用平台干所有事, 话说这也让我在思考JavaScript, 这也是为什么在软件行业我们不喜欢换平台, 我们情愿用自己不怎么称心的工具, 但就是不用别人那里的陌生的工具, 但其实是教我们不要不切实际, 先去做, 这个很重要, 而不是整天想什么框架, 到头来什么也没有拿出来, 换个思路想, 其实很多时候, 是一通百通的, 但前提是你得不断的去熟悉, 去钻研, 一旦达到了一定的高度, 会悟出许多看似简单, 却受用终身的真谛!这个时候不管怎么平台, 工具, 其实都是解决问题的手段, 甚至人的肉体其实只是精神和物质交流的一个媒介.再也没有对自身的关注, 没有仇恨, 只有爱......)这也是为什么TinyOS的开发者构建了系统和之上的应用, 但是也赋予了系统优势和弱点(吃太多自己的狗粮了). 另一方面, 这也让我们混淆了到底什么叫做困难, 什么又叫做重要.站在学术研究的立场上, 追逐困难的, 未解决的问题或许是有意义的, 但是实际上采用技术手段让有些困难的问题更容易地去解决的同时, 也让简单的问题变得难以解决了, 而这确实在TinyOS中发生了.

回顾历史, 其实我们更好的做法是让系统的设计和演变分成两半, 前者用来更容易的去构建更大更复杂的系统, 后者用来构建一个更容易进行实验的系统, 但或许激发那些研究系统和网络的研究生采用第二套方案更容易失败,但是, 我们可以想想TinyOS的开发如果让Stanford和Carnegie Mellon大学也参与而飞速地开发传感器设备的原型, 可能就会出现使用低功耗无线传感器设备开发全新的应用的例子. Arduinos, 虽然也部分填补了这一方面, 但是在网络方面却有着有限的能力.谁知道要是这些由TinyOS替代的话, 那么新的科学实验、艺术作品、或者玩具会是什么一个样子??

另一方面, nesC的演变也让我们发现了一种新的、更好的方式去编写有效的, 无错的嵌入式代码. 要是时光可以倒流, 我们首先要做的事情就是完完全全重新设计这们语言, 或者设计一个新的来更好的支持这样一种结构的编程理念, 而不是使用那些具有通用特性的语言.比如, 我们可以采用一种方式来定义可以自动完成参数设置, unique以及状态管理所有这些事情的静态虚拟化方法, 一个文件就可以定义这个服务, 而不是像现在这样, 需要至少4个文件.

h4. 8.3 Software Components(软件组件)

组件和基本的C代码比起来确实是一个很重要的提高, 他们提供了这样一种即干净的、可重用的、数据私有化又可以让一些工具可以检查确认TinyOS代码的方法(作者这里说的是编译器可以根据这样一个特性做很多的优化), 组件鼓励我们通过将一个复杂的问题、复杂的系统分解为一组小的问题, 来构成简洁的系统.小到射击定位类应用程序大到Tenet这样一个编程系统.(Tenet这个貌似很强大的样子, 有空可以看看, 一个无线传感器网络方面的论文:http://enl.usc.edu/papers/cache/Gnawali06.pdf)

h4. 8.4 Software Components Architectures(软件组件架构)

面对这些应用, 不可避免的, 学术研究更倾向于通过给系统核心定义一个架构来使得它通用化.比如说TinyOS网络层的架构, 但实际上, 后来证明这些为了这些通用性而做的努力并不比它的价值来的大, 如果针对任意给定的抽象都用很多较小的实现来做(转发规则、链路评估), 那么通用性带来的结构上的复杂度将增加它的有害性."不要通用, 通用通常都是错的", 实际上, 容易移植和修改的往往是那些简单、易于理解, 没有太多乱七八糟复杂结构的代码.其实我们一开始应该使用细粒度的组件, 然后随着时间的推移以及它的稳定, 将这些组件进行整合成一个组件.

h4. 8.5 Good: Initial Users

没有Nest项目, TinyOS项目就可能不会这么快离开Berkeley和其它一些学校去更大的世界发展.NEST带动了Berkeley的开发者将一个普通的项目变成一个真正的软件工程项目:一旦有人开始使用这些代码, 于是也就产生了影响.这也让软件能够走出Berkeley之外, 让大家可以使用、扩展以及比较它. 最终, 就创造出了一种能够让大家将社会知识和积累应用在这个项目上的契机.当一个研究者考虑使用TinyOS的时候, 就有机会知道其他人和组织已经做过了什么, 也就能从这里学到东西.

很显然, 创建这样一个初始的用户群体(应该类似于TinyOS初期伯克利里面的学生用户群体)很困难的, 里面的每个人该怎么做呢?有两种方案:一种是尽力让内部的用户使用起来, 也许其他的组织和研究者就会发现居然有这样一个很好用的系统.一个显著成功的例子是Click modular router(参考http://read.cs.ucla.edu/click/, 可以自由定制路由器), Click, 起源于MIT, 现在已经被很多的也是MIT的研究项目所使用, 比如Roofnet以及无线网络编码等项目.Click的成功显示了这不仅是一个研究性项目, 而且还是一个被许多研究者和公司使用的工具.

通常, 第二个方案更容易成功, 那就是去找一个项目, 寄生在上面, 对于TinyOS来说, 对于NEST项目, 确实需要使用TinyOS, 当然这也存在缺点.一些NEST项目的参与者仍然极力反对项目使用TinyOS. 其它成功的例子就没有那么极端了, 比如说DHash++, 它既是IRIS项目的一部分, 也是PlanetLab和Intel项目的一部分.

h4. 8.6 Bad: Focusing on Experts(坏的一面, 定位在专业用户)

回顾过去, 过多的关注技术社区的成长使得TinyOS更专注了技术的复杂度. 即使大方向是技术, 我们也应该拓宽参与度. 但是过分的追求技术的影响, 导致了研究者成了项目的主导.

虽然我们其实也可以对技术社区之外的用户产生影响(比如说MIT的X, Berkeley的BSD, CMU的Mach, 剑桥的Xen, 以及最近出现的Stanford的OpenFlow都是很显著的例子), 但是这对于嵌入式软件来说确实极其困难的. 由于嵌入式系统往往是封闭的、单一的供应商, 当供应商较少的透露底层细节时, 系统就变得垂直整合.同样有趣的是, 虽然我们知道有很多的公司在使用TinyOS开发产品, 但是能说出来的也就那么几个.

h4. 8.7 Bad: Early Industrial Involvement(工业参与过早)

TinyOS2.x刚开始的时候, 就已经有好几个公司参与了它的设计进程, 但是由于它们开发时间非常紧张, 远远超过了学术研究, 导致最终都在9个月之内放弃了参与. 长时间的讨论、无数次的设计上的迭代确实很令人沮丧, 于是Moteiv和Arch Rock公司事实上都是将源代码主分支复制到他们自己的开发分支中独立进行了.同样令人沮丧的也是目的不一样:Arch Rock和Moteiv公司都希望更关注于他们自己使用的硬件平台, 但是学术研究更希望的是能够支持多种硬件设备, 更通用.

特别的, 很多早期的来自Crossbow和Moteiv关于TinyOS2.x可编程性方面的批评, 回顾历史, 都是完全错误的.然而当时我们却错误的相信应该让工业尽早的参与进来.TinyOS其实本可以仔细的聆听来自工业合作者的表现出来的需求, 并从中受益.但是当年的这些伙伴后来却都离开了.

h4. 8.8 Good: Late Industrial Involvement(后期工业的参与)

然而06年早期的时候, TinyOS2.x核心部分一设计完成, 一些公司例如Rincon Research, handhelds.org, Zolerta以及Shockfish开始参与进来, 并且对项目产生了重大的贡献. 这些贡献的代码主要是为了驱动他们自己的硬件平台, 尽管也包含较少的一些工具库. 往往商业上的工程师更愿意为设计了很好的结构、精确稳定的接口的系统编写代码, 而不是去包容那些有时看上去像充噬着关于宇宙哲学辩论的系统.斯坦福大学的OpenFlow项目就是一个后期才开始商业合作的项目, 而不是早期.这就比TinyOS采用的方法要好.关于OpenFlow以及Xen的原始设计起源于斯坦福和剑桥.但随着时间的推移, 工业的参与着也愿意实现、扩展并且使用这个系统.

h5. 8.9 Good: Diverse Documentation

随着用户社区的成长, 文档成了一个严重的问题, 以至于有点拖后腿.虽然编写文档很消耗时间, 但是它对于长期保存问题的答案很有价值. 最终TinyOS社区决定要编写三种形式的文档: 1. 教程, 只要是用来起步的2. TEPS, 这是API和实现的一个参考. 3. 以及一份TinyOS编程手册(超过200页), 主要是深入进去, 介绍一些高级编程的细节以及软件工程的技术.教程, 关注的是如何让新的用户编写程序以及使用一些简单的函数. TEPs解释系统绝大多数的功能, 这是为了让用户去实现一些新的东西.而编程手册主要是帮助用户编写大型、复杂的软件代码.

编写好的文档有一点令人沮丧的是我们从用户那里听到的声音少了: 没有什么新的消息.于是当TinyOS wiki站点建立以后, 一些开发者开始怀疑问题越来越少是不是因为大家都离开TinyOS社区啦?!但是下载量又说明了:使用TinyOS的人越来越多了, 但是问问题的少了.

h5. 8.10 Bad: Only Developer Documentation

事实上, 为各种不同技术背景的用户编写文档是一件很有挑战性的工作.当TinyOS在早期的演变过程中, 还不是很复杂的时候, 由开发者编写的文档自然能够被其他的C程序员看懂, 但是随着系统变得越来越复杂, 专家级的开发者增多, 教程也变得既冗长又难以理解.

回顾历史, TinyOS将文档整理到wiki上也太迟了! 这主要是我们有一点担心: 一旦我们将文档开放给用户, 那么他们会写很多错误的东西.但是其实即使有一处写错了, 往往有10处相同的地方是对的.而且一旦用户认为某一段文档是正需要的, 他也会去相信它并且去积极思考, 这样也会发现其中的问题.例如, 最早的由社区贡献的文档都被放在了另外一个链接下:http://docs.tinyos.net, 这是一个很小的展示TinyOS编程的页面.我们一开始觉得, 一些小的东西我们应该把它们放在教程里面, 或者更深层次的站点里面.但是, 从历史角度看, 我们其实应该留给用户决定.

但是, 一个人根本无法做到:创建一个wiki页面, 然后希望别人让它流行.于是开发者不得不努力的整理文档.其实用户就和我们每个人一样, 他们更多关注的是能从这里得到什么而不是去为这里创造什么.

h3. 9. CONCLUSION(结论)

10年是一个很漫长的过程, 特别是对这样一个学术性的项目. TinyOS最终成功从一个UC Berkeley的学术圈内转变为由世界范围内的开发者和用户组成的社区.这是好几百的开发者成千上万小时的努力工作!从历史角度看, 一些当时我们认为很好的决定, 长远来看却起到了消极的作用, 这说明我们没有很好的预见性.例如, 虽然设计语言的扩展对于更好地提高操作系统的可编程性很有意义, 但是这样的一种操作系统的演变也疏远了新的用户, 限制了长期的发展.

TinyOS已经成为了无线传感器网络研究和工程应用最重要的推动者, 我们也看到了许多这样一些方面的努力, 比如IETF正在开发一套标准用于低功耗无限传感器和以太网的互联.随着日益增长的计算能力遍布社会的各个角落, 这种将大学的研究过渡为实际的、现实世界的影响和利益的能力仍然是重要而又有意义的.希望我们在这里学到的经验教训能够帮助其他的人在未来做出更好的尝试!

h3. 致谢

TinyOS是很多开发者共同合作的结果, 需要列在这里的太多了, 它的成功值得每一个人庆祝, 我特别需要感谢Jason Hill, David Gay, Cory Sharp, Joe Polastre, Vlado Handziski, Jan Heinrich-Hauer, Kevin Klues, David Moss, Omprakash Gnawali, Jonathan Hui, John Regehr, Matt Welsh, AlecWoo, Robert Szewczyk, Kamin Whitehouse, Philip Buonadonna,Ben Greenstein, and Miklos Maroti.另外, 如果没有David Cullar的领导, Eric Brewer富有洞察力的语言设计, Shankar Sastry的应用开发知识, 我们就不可能成功的走到今天.最后但也是最重要的是, TinyOS的成功离不开使用它的用户, 他们报告BUG、提出功能要求、努力工作, 为我们在早年很好的指明了无线传感器的研究方向.

我还要感谢SOSP 2011以及OSDI 2012这两个编程委员会, 他们在TinyOS成长过程中提出的极棒的建议让很多其他的研究者和工程师收益.

尽管这项工作得到了微软研究院、因特尔研究院、DoCoMo资本、Foundation资本, 国家科学基金会#0615308("CSR-EHS"), #0627126("NeTS-NOSS")以及#0846014（"CAREER")以及 Stanford Terman研究协会的很多的奖励, 但是在这篇材料中的发现、结论或者表达的建议都只和我个人有关, 它不代表国家科学基金会的意见.

h3. REFERENCE(引用)

请直接参看<a href="http://sing.stanford.edu/pubs/tinyos-retrospective-osdi2012.pdf">tinyos-retrospective</a>尾部的引用!

